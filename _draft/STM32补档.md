## 调试接口

ATK-DAP 是正点原子（ALIENTEK）公司推出的一款调试器/下载器，全称可能是 ALIENTEK DAP Link ，它是一个基于 CMSIS-DAP 协议实现的硬件调试工具。MDK（Microcontroller Development Kit） 是由 Keil 公司开发的一套集成开发环境（IDE），主要用于 ARM 架构的微控制器开发。IAR Embedded Workbench for ARM（简称 IAR EWARM） 是 IAR Systems 提供的另一款主流嵌入式开发 IDE，专为 ARM 架构设计。两个 IDE 各有自己的编译器。JTAG（Joint Test Action Group） 是一种标准测试协议，最初用于测试印刷电路板上的集成电路互连情况，后来被广泛用于嵌入式系统的调试和烧录。SWD（Serial Wire Debug） 是 ARM 公司提出的一种替代 JTAG 的调试接口，专为嵌入式系统设计。“仿真接口”指的是调试器（如 ATK-DAP、J-Link、ST-LINK）与目标 MCU 之间通信所使用的物理接口，根据目标芯片和调试器选择使用哪种接口。“仿真接口”是指调试器（Debugger）与目标 MCU 之间通信的物理和逻辑通道。它决定了调试器如何访问 MCU 的寄存器、内存、断点等功能。DAP（Debug Access Port） 是 ARM CoreSight 架构中的一个模块，允许调试器通过 SWD 或 JTAG 访问内核和外设寄存器。CMSIS-DAP（Cortex Microcontroller Software Interface Standard - Debug Access Port） 是 Arm 提出的一个开源调试接口协议，用于实现通用的调试适配器。keil 的 debugger 的 settings 中，可以在 Programming Algorithm 中查到 flash 容量。

## 中间件

emWin、LVGL、lwIP、uC/OS、FreeRTOS 都是嵌入式开发中非常重要的中间件或操作系统组件。emWin 全称 SEGGER emWin，是用于嵌入式系统的图形用户界面（GUI）库，需要商业授权；LVGL 是开源嵌入式图形库，适用于资源有限的嵌入式设备，完全开源；lwlP 为一个轻量级的 TCP/IP 协议栈，适用于嵌入式系统，完全开源；uC/OS-II / uC/OS-III 为硬实时内核（RTOS），需要商业授权；FreeRTOS 全称 Free Real-Time Operating System，为轻量级硬实时内核。

## 启动文件解析

startup_stm32f103xe.s

STM32 启动文件由 ST 官方提供，在官方的固件包里。启动文件由汇编编写，是系统上 电复位后第一个执行的程序。

启动文件主要做了以下工作：

1. 初始化堆栈指针 SP = \_initial_sp
2. 初始化程序计数器指针 PC = Reset_Handler
3. 设置堆和栈的大小
4. 初始化中断向量表
5. 配置外部 SRAM 作为数据存储器（可选）
6. 配置系统时钟，通过调用 SystemInit 函数（可选）
7. 调用 C 库中的 \_main 函数初始化用户堆栈，最终调用 main 函数

![image-20250523100456842](../assets/post-pics/image-20250523100456842.png)

内存空间的开辟：设置内存大小，设置内存空间段名、是否初始化、读写权限、字节对齐，后分配内存，标记结束位置。内存对齐一方面是满足处理器架构要求，ARM Cortex-M 系列内核（如 Cortex-M3/M4/M7）的栈指针（SP）必须指向一个 8 字节对齐 的地址，这是 ARM 架构规范所规定的；另一方面，现代处理器为了提升性能，往往会对数据访问有对齐要求。例如，访问一个双字（64 位）类型的数据时，如果地址不是 8 字节对齐的，可能需要两次内存访问，影响性能。此外，在使用 FPU（浮点单元）时，某些浮点操作要求栈帧必须 8 字节对齐，否则会导致错误或崩溃。

栈空间的开辟：栈是从高往低生长，所以结束地址就是栈顶地址。栈顶地址可通过.map 文件中的 initial_sp 查看。比如定义 Stack_Size 的大小是 0x00000400，通过 map 文件看到栈顶地址 initial_sp 的 地址是 0x20000788，那栈底地址就是 0x20000388。栈顶地址 0x20000788 到栈底地址 0x20000388 的内存大小刚好就是 Stack_Size 的大小。每使用一个栈空间地址，栈顶地址\_\_initial_sp 就减一。栈主要用于存放局部变量，函数形参等，属于编译器自动分配和释放的内存，栈的大小不能超过内部 SRAM 的大小。如果程序出现了莫名其妙的错误， 并进入了 HardFault 的时候，你就要考虑下是不是栈空间不够大，溢出了的问题。

堆空间的开辟：堆和栈的生长方向相反的，堆是由低向高生长，而栈是从高往低生长。堆主要用于动态内存的分配，像 malloc()、calloc()和 realloc()等函数申请的内存就在堆上面。堆中的内存一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统 回收。

PRESERVE8：指示编译器按照 8 字节对齐。

THUMB：指示编译器之后的指令为 THUMB 指令。 在 `THUMB` 指令之前（即复位向量表部分），**使用的仍然是 Thumb 指令集** ，但这是通过一种特殊机制实现的 —— **向量表中的地址最低位为 1（LSB=1）表示进入 Thumb 模式** 。

ARM 处理器在启动时默认处于 **Thumb 状态（Thumb mode）** ，所以 `THUMB` 指令只是为了告诉汇编器“我接下来用的是 Thumb 指令”，并不是切换指令集的指令。Cortex-M 系列（如 STM32 使用的 M3、M4、M7 等）只支持 **Thumb 模式** ，不支持传统的 ARM 指令集。ARM Cortex-M 内核在上电复位后自动进入 **Thumb 状态** ，这意味着你写的任何启动代码都必须是 Thumb 指令。但是，在复位向量表中，我们通常写的是地址。这些地址指向的函数，其最低位（LSB）必须为 **1** ，以告诉 CPU：“这个地址是 Thumb 代码”。因此，**即使没有写 `THUMB` 指令，向量表指向的代码也必须是 Thumb 代码** 。THUMB 伪指令只是告诉汇编器（如 armasm 或 GNU as）：“下面的代码使用 Thumb 指令集”，让汇编器正确地进行指令编码和语法检查。它并不会生成实际的机器码（不是一条 CPU 执行的指令），只是给汇编器看的提示信息。如果你使用的是 GCC 工具链（如 STM32CubeIDE），通常不需要手动加 `+1`，链接器会自动处理地址的 LSB 设置。

中断向量表定义：当内核响应了一个发生的异常后，对应的异常服务例程(ESR)就会执行。为了决定 ESR 的入口地址， 内核使用了向量表查表机制。向量表其实是一个 WORD（32 位整数）数组，每个下标对应一种异常，该下标元素的值则是该 ESR 的入口地址。向量表在地址空间中的位置是可以设置的，通过 NVIC 中的一个重定位寄存器来指出向量表的地址。在复位后，该寄存器的值为 0。因此，在地址 0 （即 FLASH 地址 0） 处必须包含一张向量表，用于初始时的异常分配。这里有个另类：地址 0x0000 0000 并 不是什么入口地址，而是给出了复位后 MSP 的初值。

DCD：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。

---

STM32 命名规则

![image-20250522234549019](../assets/post-pics/image-20250522234549019.png)

![image-20250523094538249](../assets/post-pics/image-20250523094538249.png)

![image-20250523094709198](../assets/post-pics/image-20250523094709198.png)

![image-20250523094749747](../assets/post-pics/image-20250523094749747.png)

![image-20250523094912550](../assets/post-pics/image-20250523094912550.png)

---

## 外设

摇杆实质上是电位器，摇杆处于不同位置时输出不同电压，注意需要保证模块输入电压正常，否则测得的电压值也会有偏差。

摇杆一般使用 ADC 读取输出的模拟电压，根据摇杆内阻计算确定 ADC 采样时间。

舵机由直流电机、齿轮减速箱、编码器（内含旋转电阻/电位器）和控制板组成，控制板采集电位器的输出电压得到角度反馈。绝大部分舵机使用 50Hz（周期 20ms）的 PWM 信号进行控制，占空比 2.5%和 12.5%分别对应最小旋转角度和最大旋转角度（即 500us 和 2500us）。

![f73542f65c9b55a11d2b1f600e3219c8](../assets/post-pics/f73542f65c9b55a11d2b1f600e3219c8.gif)

SG90 为最常见的舵机，塑料齿扭矩小；MG90 在此基础上使用金属齿；MG996 使用金属齿且扭矩更大。360° 舵机就是普通舵机减去编码器，不同的高电平持续时间对应旋转速度而不是角度。

直流电机对外的接口为正负两极，输入电压越高转速越快，调换极性可实现反转。

驱动电机需要的电流较大，MCU 无法驱动；电机旋转或手动旋转产生的反电动势产生的电流也较大，直接输入 MCU 也有可能烧坏芯片，因此需要电机驱动。

以 DRV8833 电机驱动为例，一颗 DRV8833 可驱动两个直流电机

![DRV8833](../assets/post-pics/DRV8833.png)

| IN1  | IN2  | OUT1   | OUT2   | 运行情况                                                                                                         |
| ---- | ---- | ------ | ------ | ---------------------------------------------------------------------------------------------------------------- |
| HIGH | LOW  | HIGH   | LOW    | 正转                                                                                                             |
| LOW  | HIGH | LOW    | HIGH   | 反转                                                                                                             |
| HIGH | HIGH | LOW    | LOW    | 相当于电机两端短路，电流慢衰减，反电动势磁场与定子磁场相互作用，电机快速刹停                                     |
| LOW  | LOW  | 高阻态 | 高阻态 | 芯片会将 OUT1 和 OUT2 输出反接，电流瞬间被释放掉（电流快衰减），电机两端为断路（高阻态），电机由于摩擦力慢慢停止 |

将高电平换成 PWM 信号可以快衰减电流控制转速，用于需要快速响应的场景，占空比越高转速越快

将低电平换成 PWM 信号可以慢衰减电流控制转速，用于需要平稳运行降低噪声的场景，占空比越低转速越快

其它常用的直流电机驱动芯片还有 L298N、TB6612 等，查阅对应资料可知其控制电机的方式，一般使用 MCU 的 GPIO 和 PWM 即可控制电机转向和转速。

参考资料

https://blog.csdn.net/sxstj/article/details/132106959

https://blog.csdn.net/weixin_43002939/article/details/130159073

编码器由带磁铁的码盘和霍尔元件组成，磁铁 N 极靠近元件产生高电平，S 极靠近元件产生低电平；码盘旋转在霍尔元件测量下产生脉冲信号，采集脉冲信号就可测得转过的距离，除以时间即可获得转速。

编码器的线数是指转过一圈产生的脉冲数，由码盘上的磁极对数决定。常用的编码器位增量式旋转编码器，有 AB 两相，两相脉冲信号由于霍尔元件的摆放位置，相位相差 90°，通过检测一相信号在上升/下降沿时，另一相为高电平/低电平，便可判断旋转方向。

![encoder111](../assets/post-pics/encoder111.png)

STM32 MCU 的定时器具有编码器接口模式，编码器两相分别接到定时器的 T1 和 T2 上就可以进行计数。单相计数时，一个脉冲会被计数两次，两相计数时，一个脉冲则会被计数四次。

![encoder222](../assets/post-pics/encoder222.png)

参考资料：

https://www.bilibili.com/video/BV1f4421U7Uj/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468

https://www.bilibili.com/video/BV1wN4y1D7LR/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468

https://www.bilibili.com/video/BV16x4y1M7EN/?spm_id_from=333.788.videopod.episodes&vd_source=1d0891b41fe4e23dbf197eaf61dfa468&p=15

步进电机基于电磁铁原理，其角度和角速度分别受控制脉冲的数量和频率控制，可以从源头上很好地控制输出。转子为永磁体，定子绕组产生矢量磁场，控制绕组的通电顺序可控制矢量磁场的方向，从而带动转子旋转。每输入一个电脉冲，转子旋转一个步距角，即最小旋转单位。

![step motor111](../assets/post-pics/step motor111.png)

步进电机分为单极性和双极性，极性指的是有几种电流流向。单极性步进电机一个电极上有两个绕组，一个绕组通电时，产生一个北极磁场； 另一个绕组通电，则产生一个南极磁场，电流方向唯一（由公共端决定电流方向）。双极性步进电机一个电极只有一个绕组，绕组电流方向决定产生的磁极方向。步进电机的相数是指产生不同对 NS 磁场的激磁线圈对数，可以理解为线圈的组数，两相电机步距角 1.8°，三相电机步距角 1.5°。步进电机的拍数是指完成一个磁场周期性变化需要的脉冲数或导电状态数。定位力矩是指不通电状态下电机转子自身的锁定力矩。静力矩是指通电不旋转状态下电机转子的锁定力矩。

![step motor222](../assets/post-pics/step motor222.png)

改变定子电流的比例，可以改变转子在一个整步中的不同位置，也就是细分的原理，细分提高了步进电机旋转的流畅度和精度。步进电机的精度大约为步距角的 3~5%，且不会累计。另外，其转矩与转速成反比。步进电机在低速时可以启动，高速时不会启动，即存在空载启动频率（最大脉冲频率），驱动信号高于这个频率会产生丢步或堵转。

步进电机可由方波数字信号驱动，对 MCU 而言可由 GPIO 或 PWM 实现。

28BYJ48 为单极性四相八拍式减速型永磁式步进电机，其最大外径 28mm，减速比 64:1，步距角(5.624/64)°，转一周所需脉冲数为 4096。该电机可由 ULN2003 芯片，该芯片由七个 NPN 达林顿管组成，是高电压、大电流复合晶体管阵列，用于放大电流提高驱动能力。

参考资料

https://doc.embedfire.com/motor/motor_tutorial/zh/latest/basis_part/stepper_motor.html

---

直流电机电机原理，见自动控制元件直流电机部分。

- 有刷直流电机用于不要求长寿命、高可靠性的作业环境。
- 无刷直流电机：简称 BLDC，噪声小且更轻巧。BLDC 的转子是永磁体，定子是磁铁，通电后线圈成为电磁铁。

![Motor1](../assets/post-pics/Motor1.png)

何时给那阿哥线圈通电励磁，是电子调速器的工作

- 异步电机/感应电机：定子是三线圈绕组，输入三相交流电产生旋转磁场，磁场旋转的速度称为同步速度。变化的磁场在回路中产生感应电动势，载流回路受到安培力作用，带动转子在磁场中旋转

![Motor2](../assets/post-pics/Motor2.png)

在感应电机中，用鼠笼式的机械结构来代替回路，鼠笼上的栅条与端环构成闭合回路，产生感应电流。

![Motor3](../assets/post-pics/Motor3.png)

![Motor4](../assets/post-pics/Motor4.png)

转子速度永远跟不上磁场的旋转速度，以略低于同步速度的速度旋转

异步电机不需要永磁体、电刷、换向器或位置传感器，可以通过控制输入电源的频率来调速（旋转磁场的速度正比于输入电源的频率）。

感应电机也可以由原动机驱动，作发电机使用，此时旋转磁场的速度会小于转子速度

- 步进电机

转子由永磁体构成，定子为通电线圈，作为电磁铁。步进电机一般有 50~100 个电磁铁，每个磁极为电机轴提供了一个自然的停止点，使得步进电机可以在没有位置反馈的情况下进行精准定位，且磁极越多定位越精准，即步进电机可以在开环系统中工作。一个脉冲信号对应一个步距角的转动，精确定位电机只需发送正确数量的脉冲即可。步进电机的转子上通常由多达 200 个齿，或电机轴旋转一周需要 200~400 步。

![Motor5](../assets/post-pics/Motor5.png)

步进电机的优势：成本低、扭矩大、可用于开环系统、控制简单（位置正比于输入脉冲数、速度正比于输入脉冲频率）、更安全（故障便停止工作）、寿命长（无电刷换向器等，只有轴承会磨损）、低速、重复定位精度高、误差不累积、过载安全（但会影响精度）、适合于恒负载场合、绕组通电且转子静止时提供满载扭矩（保持扭矩）、断电也提供扭矩（阻尼扭矩）、提供低速大扭矩、启停和反转响应好

步进电机的劣势：效率低（由于保持扭矩，无论负载如何都消耗功率）、扭矩随转速增加迅速下降，精度低于伺服电机、开环时要注意潜在的失步（如负载过大或移速过快可能丢步）、扭矩惯性比大故不能快速加速负载、中高速时噪声大、克服阻尼扭矩会降低运行时的实际扭矩

更复杂的机器人和机床一般使用带编码器和闭环控制器的伺服电机

- 伺服电机

由控制电路、电机、轴、电位器、传动齿轮、放大器和编码器构成，通过传感器实现位置反馈。伺服电机分类有三个依据：交直流、有刷无刷、同步异步。交直流的主要区别在于控制速度的能力，直流电机在负载不变情况下，转速与供电电压成正比；交流电机转速由施加电压的频率和磁极数决定；另外，交流电机能承受更大的电流，并且在需要高重复性和高精度的场景中更常见。有刷电机通过电刷和换向器换向，简单便宜；无刷电机则通过电子方式进行换向，一般通过霍尔传感器或编码器实现，效率高更可靠噪声小。直流电机通常按照有刷无刷进行分类，交流电机通常按照同步异步进行分类。

直流电机转速取决于施加的电压，通常是电位器产生电压作为放大器的输入。在一些电路中，使用控制脉冲来产生直流参考电压，参考电压与电机期望的位置和速度相对应，作用于脉宽电压转换器。反馈信号传感器往往是一个电位器，通过齿轮机构产生与电机轴绝对角度相对应的电压，输入到放大器，反馈电压与期望电压进行比较产生误差电压，作用到电机电枢上，使得电机旋转。

![Motor6](../assets/post-pics/Motor6.png)

交流伺服电机：同步交流伺服电机的定子由圆柱形框架和定子铁芯组成，电枢线圈绕在定子铁芯上；转子由永磁体组成，定子通电励磁时，转子与定子激励场，场与定子以相同速度旋转；定子不在通电时，由于没有转子电流，转子也会停转。可在转子上安装编码器获得转子与定子的相对位置。异步电机定子由定子铁芯、电枢绕组和导线组成，转子由转轴和转子铁芯组成。只有定子绕组由交流电源供电，产生旋转磁场，磁场和转子导体之间的相对速度在转子中产生感应电磁力，产生电磁转矩。

![Motor7](../assets/post-pics/Motor7.png)

---

## 通讯协议

单片机和不同外设以及其它单片机通信时，需要用到不同的通信方式，常见的有 UART、I2C、SPI、RS232、RS485 等

UART（Universal Asynchronous Receiver-Transmitter）是通用异步串行总线。物理层由相互独立的两根线实现，收发各一根，全双工通信（可同步收发），双方约定好通信速率（波特率），以数据包的形式传输数据。数据包由起始位、数据位和停止位构成。

UART 的缺点：不能远距离传输信号、通信速度慢、不能一对多通信。针对以上缺点分别衍生出了 RS232/RS485、SPI、I2C 通信方式。

RS232/RS485：由于串口通信使用 TTL 电平，故传输距离有限，一般用于同一块电路板或两块很近的电路板之间的两个芯片进行通信，否则信号容易受到干扰，远距离通信需要加入专门的芯片来抗干扰。RS232 最大通信距离可达 30m，RS485 最大通信距离可达 1000m；RS485 还支持一对多通信。

SPI：UART 的最高通信速率一般为 115200bps，由于 UART 通信需要约定波特率，而受限于 MCU 运行频率和时钟的准确性，波特率很难做到完全一致，传输速率过快容易误码。SPI 使用一个

I2C 解决单片机一对多通信的问题，通信线路少，节约 IO 资源降低 PCB 布线成本。

I2C 总线有时钟线和数据线，时钟线用于同步信号，发送端在时钟高电平时发出数据，接收端在时钟高电平接收数据。总线上配有上拉电阻，默认处于高电平状态，芯片内部打开 MOS 管就将总线信号拉低输出低电平（实际上就是 GPIO 开漏输出）。由于采用开漏输出和上拉电阻，I2C 信号的抗干扰能力较弱，一般用于同一块电路板上的芯片之间的通信。

多个设备需要同时发送数据时，由软件协议决定优先级。

---

## 嵌入式扫盲

嵌入式处理器：

MCU（单片机）是集成了处理器内核、内存、输入输出接口和时钟的单一芯片，常见的 MCU 有 89C51,STM32,ESP32；入门之选有 Arduino、树莓派（SoC 可运行 Linux 系统，芯片包含了 ARM 架构的处理器核心，ARM 公司设计了一系列低功率高性能的处理器架构）

DSP（数字信号处理）是专门用于处理数字信号（音频、图像等）的芯片：机器指令对卷积、傅里叶变换、乘除法等运算

FPGA（可编程逻辑门阵列）在实际使用前由用户编程的集成电路，利用可编程互联（verilog/VHDL）将可编程逻辑块按特定的顺序形成复杂的组合逻辑或时序逻辑

硬件包括处理器、存储器、传感器和执行器，软件包括应用程序、驱动程序、算法等，由数据+可执行代码+操作系统组成。连接软硬件的是固件，用于初始化硬件、加载操作系统或直接执行控制功能

典型的 MCU 结构与功能：处理器（CPU 运算控制寄存、时钟->定时器->中断->看门狗）、存储器（片上存储（ROM（程序启动、内核功能调用）、SRAM（运行临时数据）、Flash（程序代码、数据、固件）））、IO（外设接口、无线通信）

单片机与外部交互的方式：GPIO、PWM、ADC、DAC

芯片之间交互的方式：UART、SPI、I2C

单片机之间交互的方式：Wi-Fi，Zigbee，NB-IoT，Bluetooth，LoRa

---

## 嵌入式驱动开发规范

框架分为 App 和 Module 两层，App 为实现具体功能的应用逻辑，Module 为所有依赖的驱动，包括 Utilities，Device，Algorithm，希望全部以 lib 和头文件形式引入。

框架不再对 HAL 库提供的外设接口和数据结构作进一步的封装，而是在 HAL 库基础上编写各种外设的驱动

框架用 C 语言编写，头文件加入方式重复包含的宏定义

```c
#ifndef __XXX_H__
#define __XXX_H__

/*put your code here*/

#endif
```

框架中的数据结构用 typedef struct 或 typedef enum 进行封装

```c
typedef struct
{
	/*put your code here*/
} XXX_TypeDef;

typedef enum
{
	/*put your code here*/
} XXX_Enum;
```

头文件中的函数声明需添加注释，包括 description（描述函数功能），param 和 return（自动提取）

```c
/
 * @description:
 * @param {PWM_HandleTypeDef} *pwm
 * @return {*}
 */
```

文件注释包括 Author，LastEditTime，Description（描述文件功能）

```c
/*
 * @Author: Hatrix 3113624526@qq.com
 * @LastEditTime: 2024-12-11 15:26:35
 * @Description: PWM封装
 */
```

---

## 基础篇

### ST 单片机原理介绍

STM32，是意法半导体制造的，基于 Cortex-M 内核的 32 位可编程 MCU，采用独立的数据和地址总线访问数据和程序存储器的哈弗计算机结构，配合一些片上外设，可以实现用程序控制一系列实用的设备。

微处理器内部结构，描述了总线和单片机上各个外设之间的连接方式

全局地址空间，以 G4 系列为例

几个常用的地址映射

1. Flash 存储器映射：STM32F103 系列单片机的 Flash 存储器容量大小不同，但一般都是从 0x0800 0000 地址开始映射的。用户程序代码和常量数据通常存储在 Flash 存储器中。
2. SRAM 存储器映射：STM32F103 系列单片机的 SRAM 存储器容量也不同，但一般都是从 0x2000 0000 地址开始映射的。程序中使用的变量、堆栈和缓存等通常存储在 SRAM 存储器中。
3. 外设寄存器映射：STM32F103 系列单片机有许多外设，每个外设都有一些寄存器用于配置和控制，这些寄存器通常映射在 0x4000 0000 到 0x5FFF FFFF 的地址范围内。每个外设的寄存器地址和访问方式都有一定的规定，需要查阅相关的技术文档来了解。
4. System Memory 映射：STM32F103 系列单片机的 System Memory 是指内置的 Bootloader 程序存储区域，这个区域的地址范围是从 0x1FFF F000 到 0x1FFF F7FF，大小为 2KB
5. 位带映射：STM32F103 系列单片机的位带映射功能可以将某个单个位的读写操作映射到一个整个“字”的读写操作，这种映射方式可以提高对某些位操作的效率，但需要在编程时进行特殊的设置。

为了提高位操作的效率，一些单片机引入了位带映射技术。该技术通过将每个位（bit）与一个单独的内存地址进行映射，使得对该位的操作可以像对内存变量一样进行，从而可以大大简化位操作的流程。

### ST 芯片文档分类

- 参考手册：一般面向应用程序开发人员，详细完整。为用户使用单片机提供了完整的存储器和外设信息。
- 数据手册：介绍了芯片的主要外设资源和电特性参数。
- 编程手册：为单片机用户提供完整的编程指南。
- 用户手册：各种软件硬件的操作方法。
- 应用笔记：一些具体问题的解决方案。

一般来说，用得最多的是参考手册

### ST 芯片命名规则

### ST 芯片选型

1. 应用场景和需求：首先需要明确使用 STM32 的应用场景和需求，例如需要控制什么设备或执行什么任务，需要处理多少数据和信号，需要多大的处理能力和存储空间等。这些因素将直接决定 STM32 芯片的选型范围和性能要求。
2. 外设和接口：STM32 支持各种不同的外设和接口，例如通用输入输出（GPIO）、模拟转换器（ADC）、通用同步异步收发器（USART）、USB、以太网等。需要根据具体应用的需要选择适合的外设和接口，同时也需要考虑这些外设和接口的电气特性、数量、速率和支持程度等。
3. 处理器内核和架构：STM32 支持不同的 ARM Cortex 处理器内核和架构，包括 Cortex-M0、Cortex-M3、Cortex-M4、Cortex-M7 等。需要根据具体应用的需求选择适合的处理器内核和架构，例如需要更高的计算性能、更多的存储空间和更高的时钟速度等。
4. 电源管理和功耗：STM32 支持不同的电源管理和功耗优化技术，包括低功耗模式、睡眠模式、停机模式等。需要根据应用场景和电源供应条件选择适合的电源管理和功耗优化方案，以达到更长的电池寿命和更低的功耗。
5. 可用的开发工具和平台支持：选型 STM32 还需要考虑可用的开发工具和平台支持，例如开发板、软件开发工具、在线论坛、文档等。需要选择适合自己的开发工具和平台，以便更快速、更准确地进行开发和测试。

## HAL 库

https://www.eet-china.com/mp/a330816.html

STM32 有三种开发方式：直接配置寄存器、标准库和 HAL 库；对于 STM32 而言，寄存器的数量庞大，直接配置寄存器需要经常性的翻阅数据手册，不建议使用；而对于后面两种库的封装，目前 HAL 库更为普遍，原因在于 ST 公司已经停止更新标准库，转而主推 HAL 库。此外，随着 STM32CubeMX 和 STM32CubeIDE 等工具的支持，HAL 库提供了更加便捷的开发体验，允许开发者通过图形化界面配置外设并生成初始化代码。尽管 HAL 库可能会带来更大的代码体积和稍慢的运行速度，但其易用性和官方支持使得它成为许多开发者的首选。

HAL 库几大特点

1. 句柄 Handle

句柄中包含了一个外设在整个项目流程中都要设置的各个成员变量，使用时调用初始化时定义的句柄就好。

1. MSP 函数

MCU Specific Package，是指和 MCU 相关的初始化，可以配合句柄达到很强的移植性。

1. Callback 函数

类似于 MSP 函数，主要帮助用户应用层的代码编写。以中断为例，HAL 库中断服务程序接管对中断的判断、读出数据到缓冲区，清除中断标志位等等，用户在 Callback 回调函数中编写处理逻辑即可。

HAL 库结构：

stm32f4xx.h：同系列芯片的不同具体型号的定义，是否使用 HAL 库等的定义，并根据定义的芯片型号包含具体的芯片型号的头文件

hal.h：HAL 库通用部分，初始化，获取时刻，延时等

hal_def.h：HAL_StatusTypeDef， HAL_LockTypeDef 等 HAL 库通用宏定义

hal_cortex.h：Cortex 内核常量，如中断优先级定义

hal_conf.h：hal 驱动程序配置，启用 MCU 上哪些外设，对 RCC 时钟频率设置，用户级别的配置文件，实现对 hal 库的裁剪

stm32f4xx_hal_ppp.c/.h：库文件，主要的外设或者模块的驱动源文件，包含了该外设的通用 API；stm32f4xx_hal_ppp_ex.c/.h：外围设备或模块驱动程序的扩展文件。这组文件中包含特定型号或者系列的芯片的特殊 API。以及如果该特定的芯片内部有不同的实现方式，则该文件中的特殊 API 将覆盖\_ppp 中的通用 API。

hal_msp.c：MCU Specific package 特定程序包，只有.c 没有.h。包含用户应用程序中使用的外设的 MSP 初始化和反初始化

system_stm32f4xx.c：系统初始化，系统核心时钟更新；包含 SystemInit()函数，该函数在刚复位及跳到 main 之前的启动过程中被调用

startup_stm32f4xx.s：芯片启动文件，主要包含堆栈定义，终端向量表等；MCU 复位后首先要执行的程序，初始化 SP 和 PC，中断向量表，执行 SystemInit，执行 main

it.h：中断函数原型，中断服务例程 ISR

main.c：调用 HAL 库初始化，配置系统时钟，外设初始化；main 函数：HAL 库初始化，系统时钟配置，外设初始化，while（1）

main.h：引脚别名

HAL 库提供 API 可以分为三类

1. 初始化/反初始化：HAL_PPP_Init(), HAL_PPP_DeInit()
2. IO 操作：HAL_PPP_Read(),HAL_PPP_Write(),HAL_PPP_Transmit(), HAL_PPP_Receive()
3. 控制：HAL_PPP_Set(),HAL_PPP_Get()
4. 状态和错误：HAL_PPP_GetState (), HAL_PPP_GetError ()

在此结构下，用户代码的处理主要分为：处理句柄外设（实现用户功能）、处理 MSP、处理各种回调函数三部分

1. 外设句柄定义

每个外设抽象成了一个称为 ppp_HandleTypeDef 的结构体，其中 ppp 就是每个外设的名字。所有的函数都是工作在 ppp_HandleTypeDef 指针之下。外设句柄支持多实例，即每个外设/模块实例都有自己的句柄。因此，实例资源是独立的下面，以 ADC 为例，外围进程相互通信：该句柄用于管理进程例程之间的共享数据资源。

```
typedef struct
{
  ADC_TypeDef                   *Instance;              /*!< Register base address */
  ADC_InitTypeDef               Init;                   /*!< ADC initialization parameters and regular conversions setting */
  DMA_HandleTypeDef             *DMA_Handle;            /*!< Pointer DMA Handler */
  HAL_LockTypeDef               Lock;                   /*!< ADC locking object */
  __IO uint32_t                 State;                  /*!< ADC communication state (bitmap of ADC states) */
  __IO uint32_t                 ErrorCode;              /*!< ADC Error code */
  ADC_InjectionConfigTypeDef    InjectionConfig ;       /*!< ADC injected channel configuration build-up structure */
} ADC_HandleTypeDef;
```

当然，对于那些共享型外设或者说系统外设来说，他们不需要进行以上这样的抽象，这些部分与原来的标准外设库函数基本一样。如：GPIO，SYSTICK，NVIC，RCC，FLASH

1. 三种编程模式

HAL 库对所有的函数模型也进行了统一。在 HAL 库中，支持三种编程模式：轮询模式、中断模式、DMA 模式（如果外设支持）。其分别对应三种类型的函数，如

```
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length);
HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc);
```

此外，新的 HAL 库架构下统一采用宏的形式对各种中断等进行配置，针对每种外设主要有以下宏：

```
__HAL_PPP_ENABLE_IT(HANDLE, INTERRUPT)：使能一个指定的外设中断
__HAL_PPP_DISABLE_IT(HANDLE, INTERRUPT)：失能一个指定的外设中断
__HAL_PPP_GET_IT (HANDLE, __ INTERRUPT __)：获得一个指定的外设中断状态
__HAL_PPP_CLEAR_IT (HANDLE, __ INTERRUPT __)：清除一个指定的外设的中断状态
__HAL_PPP_GET_FLAG (HANDLE, FLAG)：获取一个指定的外设的标志状态
__HAL_PPP_CLEAR_FLAG (HANDLE, FLAG)：清除一个指定的外设的标志状态
__HAL_PPP_ENABLE(HANDLE) ：使能外设
__HAL_PPP_DISABLE(HANDLE) ：失能外设
__HAL_PPP_XXXX (HANDLE, PARAM) ：指定外设的宏定义
__HAL_PPP_GET_IT_SOURCE (HANDLE, __ INTERRUPT __)：检查中断源
```

1. 三大回调函数

在 HAL 库的源码中，到处可见一些以\_\_weak 开头的函数，而且这些函数，有些已经被实现了，有的则没有被实现。

通常来说，HAL 库负责整个处理和 MCU 外设的处理逻辑，并将必要部分以回调函数的形式给出到用户，用户只需要在对应的回调函数中做修改即可。HAL 库包含如下三种用户级别回调函数（PPP 为外设名）：

1. 外设系统级初始化/解除初始化回调函数（用户代码的第二大部分，即对于 MSP 的处理），在 HAL_PPP_Init() 函数中被调用，用来初始化底层相关的设备（GPIOs, clock, DMA, interrupt），如：

2. 1.

   外设系统级初始化/解除初始化回调函数（用户代码的第二大部分，即对于 MSP 的处理），在 HAL_PPP_Init() 函数中被调用，用来初始化底层相关的设备（GPIOs, clock, DMA, interrupt），如：

```
__weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
```

1. 处理完成回调函数：HAL_PPP_ProcessCpltCallback\*（Process 指具体某种处理，如 UART 的 Tx），如：

2. 1.

   处理完成回调函数：HAL_PPP_ProcessCpltCallback\*（Process 指具体某种处理，如 UART 的 Tx），如：

```
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
```

当外设或者 DMA 工作完成后时，触发中断，该回调函数会在外设中断处理函数或者 DMA 的中断处理函数中被调用错误处理回调函数

- 3、当外设或者 DMA 出现错误时，触发中断，该回调函数会在外设中断处理函数或者 DMA 的中断处理函数中被调用错误处理回调函数，如：

```
__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef hspi)*
```

HAL 库结构中，在每次初始化前（尤其是在多次调用初始化前），先调用对应的反初始化（DeInit）函数是非常有必要的。某些外设多次初始化时不调用返回会导致初始化失败。

（用户代码的第三大部分：对于上面第二点和第三点的各种回调函数的处理）在实际使用中，发现 HAL 仍有不少问题，例如在使用 USB 时，其库配置存在问题。

## 时钟源和时钟树

为什么需要时钟信号

1. 门电路运行有延迟，导致运行中的混乱状态，一种解决思路是加上边沿触发器，用时钟信号统一控制 ，使得门电路稳定之后再触发
2. 许多外设需要精确的时钟脉冲信号，比如串口的波特率、定时器计时、IIC 和 SPI 的时钟线、ADC 的采样间隔

晶振提供相对准确的时钟信号，RCC_OSC_IN 和 RCC_OSC_OUT 是外部晶振输入输出，OSC 是 oscillator（振荡器）的缩写

AHPB（Advanced High Performance Bus）被称为先进高性能总线的总线结构，处理器，内存，DMA 以及各种外设都连接在这一总线上，HCLK 是这一总线中的时钟线；处理器、内存和 DMA 直连 HCLK

处理器内核中有一个称为 SysTick（系统滴答）的定时器，通过分频器与 HCLK 连接（To Cortex System Timer）

外设时钟分门别类地连接在两个 APB（Advanced Peripheral Bus）总线上，APB 总线通过一种桥接器连接到 AHB 总线上，HCLK 经过分频器连接到 APB 上，分频后的时钟信号称为 PCLK1，PCLK2；定时器外设前，还有一个倍频器，ADC 还有一个专属的预分频器（ADC 需要采集一段时间才能更准确地获取电压值，因此时钟频率需要慢下来）

HCLK 地来源有二：HSI 和 HSE，HSI 是默认使用的时钟源，无需外部电路，精度较差；HSE 需要从外部接入晶振，脉冲精度较高，选择其一接入时钟数，接入的信号称为 SYSCLK，再经过分频器接入 HCLK

系统时钟还有一个选项，也就是 PLLCLK 锁相环时钟，起倍频器的作用，其输入可以是 HSI 或 HSE

FCLK 自由运行时钟（free running），低功耗模式的停止模式时，HCLK 停止传输时钟脉冲，FCLK 会继续运行，为唤醒的中断采样提供时钟信号

CSS 时钟安全系统，在 HSE 发生故障时，立即将时钟源切换回 HSI 并产生中断

LSE 和 LSI 供给 RTC 时钟和看门狗

MCO 时钟输出功能

SYSCLK 直接作为 Ethernet 精确时钟协议 PTP 的时钟信号

LSE 固定为 32.768KHz，可以通过一个 15 位的二进制计数器精确分频为 1Hz；LSI 为 32KHz

### 外设介绍

### 通用输入输出端口 GPIO

STM32 的 GPIO（通用输入/输出）引脚设计用于执行一系列的输入和输出操作。GPIO 是微控制器与外部设备交互的主要方式之一，可以用于多种不同的应用。

STM32 有多个 GPIO（通用输入输出引脚）端口，每个端口有 16 个引脚和 4 个 32 位寄存器，GPIO 内部的电路结构大致如下：

输出有两个控制指令的来源，一个是用 WritePin 控制的输出寄存器，另一个是串口等的片上外设，根据控制来源的不同，分为普通输出和复用输出

GPIO 有八种模式，分别是： 输入浮空，输入上拉，输入下拉，模拟，上拉或下拉的开漏输出（用于共用总线的信号），上拉或下拉的推挽输出（为增强驱动能力可以上拉），上拉或下拉的复用功能推挽，上拉或下拉的复用功能开漏

推荐阅读：

[GPIO(简介、IO 端口基本结构、GPIO 的八种模式、GPIO 寄存器、通用外设驱动模型、GPIO 配置步骤、编程实战)-CSDN 博客](https://blog.csdn.net/wdxabc1/article/details/139192494)

[单片机的上拉电阻 到底在拉什么？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1Kb411o7ai/?spm_id_from=333.788)

[推挽 开漏 高阻 这都是谁想出来的词？？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1D84y1c7GV/?spm_id_from=333.788&vd_source=1d0891b41fe4e23dbf197eaf61dfa468)

### 定时器

STM32 的定时器分为高级控制定时器，通用定时器，基础定时器三类。基础定时器只能用于定时，另外两种还具有输入捕获 Input Compare、输出比较 Output Compare、PWM 输出等功能。

### 中断与 DMA

### 串口通讯

### Debug 外设工作原理

DBG 支持模块（红框标注部分，也可以看作一个外设）通过一条专用的 AHB-AP 总线和调试接口相连（Jtag 或 swd），并且有与数据和外设总线直接相连的桥接器。它还同时连接了中断嵌套管理器（因此同样可以捕获中断并进行 debug）和 ITM、DWT、FPB 这些调试支持模块。因此 DBG 可以直接获取内存或片上外设内的数据而不需要占用 CPU 的资源，并将这些数据通过专用外设总线发送给调试器，进而在上位机中读取。

FPB 是 flash patch breakpoint 闪存指令断点的缩写，用于提供代码断点插入的支持，当 CPU 的指令寄存器读取到某一条指令时，FPB 会监测到它的动作，并通知 TPIU 暂停 CPU 进行现场保护。

DWT 是 data watch trace 数据观察与追踪单元的缩写，用于比较 debug 变量的大小，并追踪变量值的变化。当你设定了比较断点规则（当某个数据大于/小于某个值时暂停程序）或将变量加入 watch 进行查看，DWT 就会开始工作。DWT 还提供了一个额外的计时器，即所有可见的 TIM 资源之外的另一个硬件计时器（因为调试其他硬件定时器的计时由于时钟变化可能定时不准，而 DWT 定时器是始终正常运行的）。它用于给自身和其他调试器模块产生的信息打上时间戳。我们的 bsp 中也封装了 dwt 计时器，你可以使用它来计时。

ITM 是 instrument trace macrocell 指令追踪宏单元的缩写，它用于提供非阻塞式的日志发送支持（相当于大家常用的串口调试），SEGGER RTT 就可以利用这个模块，向上位机发送日志和信息。这个硬件还可以追踪 CPU 执行的所有指令，这也被称作 trace（跟踪），并将执行过的指令全部通过调试器发送给上位机。当 debug 无法定位 bug 所在的时候，逐条查看 cpu 执行的指令是一个绝佳的办法，特别是你有大量的中断或开启了实时系统时。

以上三个模块都需要通过 TPIU（trace port interface unit）和外部调试器（j-link 等）进行连接，TPIU 会将三个模块发来的数据进行封装并通过 DWT 记录时间，发送给上位机。

### GDB 调试 MCU 原理

不论使用 MDK（KEIL）还是 VSCode 还是 Ozone，实际上背后的流程相同。首先 GDB 会建立 TCP/IP 端口并提供接口，调试服务器（Server）作为硬件调试器和 GDB 软件的桥梁，将硬件调试器的相关功能（也就是 DBG 外设支持的那些功能）映射到 GDB 的接口上（通过连接到 GDB 建立的端口）。之后启动调试，将可执行文件下载到目标 MCU 上，然后从 main 开始执行

当然你也可以选择从其他启动点开始执行，调试器开始执行的位置叫做 entry point。同样，在 MCU 已经正在运行程序的时候，可以 attach 到程序上开始监控（attach=附加，贴上；很形象了）。

而对于直接运行在电脑上的程序（.exe），就不需要 GDBserver 和物理调试器，GDB 程序可以直接访问电脑上运行的程序和 CPU 的寄存器等。
