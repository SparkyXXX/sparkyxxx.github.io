## 嵌入式通信上

https://www.bilibili.com/video/BV1ju411W7Q3/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468

### 一、通信协议分层模型

根据 OSI 七层模型：

- 物理层：定义通讯速率、电平范围、线缆类型（如同轴/双绞线）等物理特性
- 数据链路层：负责比特流切分与帧识别，定义数据内部结构

### 二、通信方式演进

#### 1. 单线半双工通信

- 基本限制：必须分主从或约定发送时序，否则会产生冲突
- 速率必须提前约定，接收方需固定采样频率
- 典型应用：LIN 总线（汽车电子）

#### 2. 双线全双工通信（UART）

- 通过增加一根线实现收发分离
- 数据帧结构：起始位+8bit 数据+停止位，空闲时为高电平
- 缺点：帧长度固定，灵活性不足

#### 3. 同步通信方案

- 增加时钟线（如 I²C、SPI）
- 采样方式：
  - 约定时钟边沿触发（上升沿/下降沿）
  - 时钟高电平时数据线保持稳定，低电平时允许变化
- I²C 特性：
  - 开漏输出+线与特性
  - 支持多主机仲裁
  - 从机可通过拉低时钟线控制传输节奏
- SPI 特性：
  - 全双工通信
  - 增加片选线实现多从机选择
  - 数据传输效率更高

### 三、抗干扰解决方案

#### 1. 差分信号传输

- 原理：使用极性相反的两根线传输信号
- 优势：
  - 共模干扰抑制（外部干扰被差分抵消）
  - 电磁辐射相互抵消（双绞线结构）
- 典型应用：
  - 以太网（百兆用 2 对，千兆用 4 对双绞线）
  - CAN 总线（汽车电子）

#### 2. 终端电阻设计

- 作用：消除阻抗不匹配导致的信号反射
- 类比：类似海浪冲击沙滩时的能量吸收
- 典型值：CAN 总线常用 120Ω 终端电阻

### 四、典型总线对比

| 总线类型 | 线数                  | 工作模式 | 同步方式 | 物理层特性 | 典型应用     |
| -------- | --------------------- | -------- | -------- | ---------- | ------------ |
| UART     | 2（TX/RX）            | 全双工   | 异步     | 单端信号   | 板级设备通信 |
| I²C      | 2（SCL/SDA）          | 半双工   | 同步     | 开漏输出   | 传感器通信   |
| SPI      | 4（SCK/MOSI/MISO/SS） | 全双工   | 同步     | 推挽输出   | 高速外设     |
| CAN      | 1（差分对）           | 半双工   | 异步     | 差分信号   | 汽车电子     |

### 五、传输距离与速率关系

- 板级通信（I²C/SPI/UART）：通常＜ 1 米
- 差分信号通信（CAN/以太网）：可达 1000 米（速率降低时）
- 距离限制主要来自：
  - 线缆电阻/电容效应
  - 信号衰减
  - 电磁干扰

## 嵌入式通信下

核心关键词： 时钟恢复 编码技术 信号调制 DDR PAM3 以太网 带宽效率

### 一、时钟恢复技术

#### 1. 异步通信的挑战

- 长距离传输无法使用独立时钟线
- 单纯速率约定难以保证采样可靠性

#### 2. CDR（时钟数据恢复）原理

- 通过数据线边沿恢复时钟信号
- 使用 PLL 锁相环建立电压反馈
- 关键要求：数据需保持足够跳变率

### 二、编码技术

#### 1. 常见编码方案

- 曼彻斯特编码

  ：

  - 每个比特位都有跳变
  - 编码效率 50%
  - 10M 以太网使用

- 4B/5B 编码

  ：

  - 5bit 表示 4bit 数据
  - 编码效率 80%
  - 百兆以太网使用

- 8B/10B 编码

  ：

  - 千兆以太网使用
  - 平衡 0/1 分布

### 三、速率提升技术

#### 1. 频率提升限制

- I²C 速率演进：
  - 标准模式：100Kbps
  - 快速模式：400Kbps
  - 高速模式：3.4Mbps
  - 超高速模式：5Mbps（单向传输）
- 瓶颈因素：
  - 总线电容增加
  - 信号质量下降
  - 电磁辐射增强

#### 2. DDR（双倍数据率）技术

- 时钟上下边沿均传输数据
- 应用实例：
  - DDR 内存
  - RGMII 接口（千兆以太网）

#### 3. 并行传输方案

- SPI 变种：
  - Dual SPI
  - Quad SPI
  - OSPI
- 实现挑战：
  - PCB 等长布线
  - 建立/保持时间控制

#### 4. 信号调制技术

##### PAM3 调制技术（车载以太网）

- 使用-1/0/+1 三个电平状态
- 每个符号周期携带 1.58bit 信息(log₂3)
- 优势：
  - 66.6MHz 时钟实现 100Mbps 速率
  - 降低 EMI 辐射
- 对比传统 NRZ：

  - 带宽效率提升 50%
  - 更适合车规 EMC 要求

- 高级调制技术：
  - PAM4：4 个电平状态
  - PAM16：16 个电平状态
  - 实现挑战：
    - 需要精确幅值控制
    - 增加误码率
    - 部分带宽用于校验

### 四、技术对比与应用

| 技术         | 原理           | 带宽效率 | 典型应用    | 实现复杂度 |
| ------------ | -------------- | -------- | ----------- | ---------- |
| 曼彻斯特编码 | 每位都有跳变   | 50%      | 10M 以太网  | 低         |
| 4B/5B 编码   | 5bit 编码 4bit | 80%      | 100M 以太网 | 中         |
| DDR          | 双沿采样       | 100%提升 | DDR 内存    | 高         |
| PAM3         | 三电平调制     | ~150%    | 车载以太网  | 很高       |

### 五、设计权衡

- 效率 vs 复杂度：高级技术需要专用 PHY 芯片
- 速率 vsEMI：高频信号带来辐射挑战
- 成本 vs 性能：车规应用选择 PAM3 而非更高阶调制

## keil 设置

替换 keil 安装目录下的 global.prop 文件可以美化界面

- ARM Compiler 5 (AC5) ：这是 Keil 提供的早期编译器版本，基于 ARM 公司的 RealView Compiler 技术。AC5 是一个成熟的编译器，支持多种 ARM 架构，但功能相对有限。
- ARM Compiler 6 (AC6) ：这是 Keil 提供的最新编译器版本，基于 LLVM/Clang 技术。AC6 提供了更好的性能、更高的代码优化能力和对现代 ARM 架构（如 Cortex-M 系列）的支持。AC6 是 Keil 的推荐编译器。

- ARM Compiler ：这是 Keil 提供的官方编译器，分为 AC5 和 AC6 两个版本。AC6 基于 LLVM/Clang 技术，因此也被称为 `ARMCLANG`。
- GCC Compiler ：GNU Compiler Collection（GCC）是一个开源的编译器集合，支持多种编程语言（C、C++、汇编等），并广泛用于嵌入式开发。Keil 支持使用 GCC 编译器进行项目开发。
- ARM 的 Clang 编译器是基于 LLVM（Low Level Virtual Machine）项目的 Clang 编译器实现。Clang 是一个现代的编译器前端，支持 C、C++ 和 Objective-C 等语言，并且具有模块化的设计，易于扩展和维护。
- C 语言编译器 ：ARM 的 Clang 编译器主要用于编译 C 语言代码。它支持标准的 C 语法，并且可以生成高效的机器码。
- 汇编语言编译器 ：ARM 提供了专门的汇编器（如 `armasm` 或 `armclang` 的汇编模式），用于编译汇编语言代码。汇编代码通常用于性能敏感的部分或底层硬件操作。
- GCC（GNU Compiler Collection）是由 GNU 项目开发的一套开源编译器集合，支持多种编程语言（包括 C、C++、Fortran、Ada 等）。GCC 是嵌入式开发中非常流行的编译器，尤其在裸机开发和 Linux 系统开发中被广泛使用。
- ARMCLANG 是 Keil 提供的商业编译器，专为 Keil MDK 设计，而 GCC 是开源编译器，适用于多种开发环境。
- `arm-none-eabi-` 是 GCC 工具链中的一个目标前缀，表示编译器的目标平台是基于 ARM 架构的嵌入式系统，没有操作系统（None），并且使用 Embedded ABI（Application Binary Interface）。eabi 表示使用 Embedded Application Binary Interface，这是一种专门为嵌入式系统设计的二进制接口规范。

汇编源文件扩展名为.s 或.a，目标文件扩展名为.o 或.obj

魔术棒中可以配置存储器映射，有片外存储和片内存储（片内即 MCU 内集成的），ROM 和 RAM 都是。可以配置使用的编译器版本、是否使用 microlib、是否使用大端模式（CM3/CM4 为小端模式）、硬件支持的浮点数精度

create lib 做库？

## C 语言相关

在 C 或 C++编译器中，C99 标准 是 C 语言的一种版本标准。设置中的 “C99” 是指你希望你的代码按照 ISO C99 标准 来编译。C 语言并不是一成不变的，它随着时代发展不断更新和完善。为了统一不同编译器的行为，国际标准化组织（ISO）制定了多个 C 语言的标准版本，这些标准定义了语法规则、数据类型、库函数行为规范等。用于控制编译器如何解析你的代码，哪些语法是允许的，哪些是不被支持的，影响库函数是否可用、变量声明方式、关键字识别等。

DLL（Dynamic Link Library，动态链接库） 是 Windows 系统中一种非常常见的文件类型，它包含了可被多个程序共享使用的代码和数据。

位操作：

![image-20250525085850831](../assets/post-pics/image-20250525085850831.png)

带参数的宏：使用 do{...}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。

条件编译

指针最常见的两大问题是：未分配内存就使用、越界使用

## STM32 系统框架

AHB：高级高性能总线

APB：高级外围总线

系统架构图

![image-20250525090729497](../assets/post-pics/image-20250525090729497.png)

![image-20250525090738681](../assets/post-pics/image-20250525090738681.png)

## 存储器映射

32 位单片机有 32 根地址线，内存地址访问按字节编址而不是 bit，对存储器分配地址的过程称为存储器映射

（下图中应为 Gb 和 Mb）

![image-20250525091054618](../assets/post-pics/image-20250525091054618.png)

每个 block 的功能划分可见数据手册的存储器映射图

## 寄存器映射

![image-20250525091406431](../assets/post-pics/image-20250525091406431.png)

内核寄存器（Core Registers）

| 缩写    | 全称                                             | 中文含义                     | 说明                                 |
| ------- | ------------------------------------------------ | ---------------------------- | ------------------------------------ |
| R0~R15  | General Purpose Register                         | 通用寄存器                   | 存储数据和地址                       |
| xPSR    | Extended Program Status Register                 | 扩展程序状态寄存器           | 包含程序状态信息（如条件码、模式等） |
| NVIC    | Nested Vector Interrupt Controller               | 嵌套向量中断控制器           | 管理中断优先级与响应                 |
| ISER    | Interrupt Set-Enable Register                    | 中断设置使能寄存器           | 用于使能中断通道                     |
| ICER    | Interrupt Clear-Enable Register                  | 中断清除使能寄存器           | 用于禁用中断通道                     |
| ISPR    | Interrupt Set-Pending Register                   | 中断设置挂起寄存器           | 手动挂起中断请求                     |
| IP      | Interrupt Priority Register                      | 中断优先级寄存器             | 配置中断的优先级                     |
| SCB     | System Control Block                             | 系统控制块                   | 包含系统控制相关寄存器               |
| VTOR    | Vector Table Offset Register                     | 向量表偏移寄存器             | 设置向量表基地址                     |
| AIRCR   | Application Interrupt and Reset Control Register | 应用程序中断和复位控制寄存器 | 控制中断和复位功能                   |
| SCR     | System Control Register                          | 系统控制寄存器               | 控制系统运行模式                     |
| SysTick | System Timer                                     | 系统滴答定时器               | 提供周期性时间基准                   |
| CTRL    | Control Register                                 | 控制寄存器                   | SysTick 的控制寄存器                 |
| LOAD    | Load Value Register                              | 加载值寄存器                 | 设置计数器最大值                     |
| VAL     | Current Value Register                           | 当前值寄存器                 | 显示当前计数值                       |
| CALIB   | Calibration Register                             | 校准寄存器                   | 获取时钟频率相关信息                 |
| ETM     | Embedded Trace Macrocell                         | 嵌入式跟踪宏单元             | 调试/跟踪 CPU 执行流程               |
| ITM     | Instrumentation Trace Macrocell                  | 仪器跟踪宏单元               | 输出调试信息                         |
| DWT     | Data Watchpoint and Trace Unit                   | 数据观察点和跟踪单元         | 设置数据观察点                       |
| PIPU    | Program Interface Unit                           | 程序接口单元                 | 调试和编程接口                       |

给寄存器命名的过程就是寄存器映射

![image-20250525091757737](../assets/post-pics/image-20250525091757737.png)

![image-20250525091832871](../assets/post-pics/image-20250525091832871.png)

![image-20250525091849853](../assets/post-pics/image-20250525091849853.png)

![image-20250525091906501](../assets/post-pics/image-20250525091906501.png)

![image-20250525092005685](../assets/post-pics/image-20250525092005685.png)

![image-20250525092024303](../assets/post-pics/image-20250525092024303.png)

![image-20250525092033551](../assets/post-pics/image-20250525092033551.png)

![image-20250525092049553](../assets/post-pics/image-20250525092049553.png)

![image-20250525092158104](../assets/post-pics/image-20250525092158104.png)

![image-20250525093206117](../assets/post-pics/image-20250525093206117.png)

## CMSIS

CMSIS (微控制器软件接口标准)：Cortex Microcontroller Software Interface Standard，是由 ARM 和与其合作的芯片厂商、软件工具厂商，共同制定的标准

![image-20250525093326168](../assets/post-pics/image-20250525093326168.png)

![image-20250525093420894](../assets/post-pics/image-20250525093420894.png)

![image-20250525093446840](../assets/post-pics/image-20250525093446840.png)

![image-20250525093524201](../assets/post-pics/image-20250525093524201.png)

## HAL 库

![image-20250525093615354](../assets/post-pics/image-20250525093615354.png)

![image-20250525093628560](../assets/post-pics/image-20250525093628560.png)

![image-20250525093713211](../assets/post-pics/image-20250525093713211.png)

![image-20250525093800751](../assets/post-pics/image-20250525093800751.png)

回调函数 是一个通过函数指针传递给另一个函数的函数。当某个特定事件发生或某个操作完成后，这个被传入的函数就会被“调用回来”，因此得名 回调函数（Callback Function） 。

![image-20250525094103159](../assets/post-pics/image-20250525094103159.png)

![image-20250525094159728](../assets/post-pics/image-20250525094159728.png)

HAL 库的用户配置文件（stm32f1 xx hal conf.h)

1,裁剪 HAL 库外设驱动源码（不进行编译）

2,设置外部高速晶振频率（根据开发板实际情况设置）

3,设置外部低速晶振频率（根据开发板实际情况设置）

![image-20250525095710669](../assets/post-pics/image-20250525095710669.png)

HAL 库使用注意事项 1,使用 HAL 库出现问题，还是得通过参考手册检查是否硬件操作是否有问题 2,尽量不通过修改库源码实现功能，这样不方便库更新 3,HAL 库可能会存在错误，要有质疑精神 4,有些 HAL 库 API 函数执行效率偏低，我们可能会直接通过操作寄存器的方式代替

## 启动过程

![image-20250525100258048](../assets/post-pics/image-20250525100258048.png)

MAP 文件是 MDK 编译代码后，产生的集程序、数据及 IO 空间的一种映射列表文件。简单说就是包括了：各种.c 文件、函数、符号等的地址、大小、引用关系等信息。分析各.c 文件占用 FLASH 和 RAM 的大小，方便优化代码。学会分析：哪个.c 占用 flash 和 ram 比较大，以便针对性的优化

![image-20250525100505550](../assets/post-pics/image-20250525100505550.png)

![image-20250525100634056](../assets/post-pics/image-20250525100634056.png)

在系统复位后，SYSCLK 的第 4 个上升沿，BOOT 引脚的值将被锁存

![image-20250525100840215](../assets/post-pics/image-20250525100840215.png)

![image-20250525100849953](../assets/post-pics/image-20250525100849953.png)

![image-20250525100906131](../assets/post-pics/image-20250525100906131.png)

![image-20250525100918705](../assets/post-pics/image-20250525100918705.png)

## 时钟系统

![image-20250525101133791](../assets/post-pics/image-20250525101133791.png)

![image-20250525101315363](../assets/post-pics/image-20250525101315363.png)

![image-20250525101333689](../assets/post-pics/image-20250525101333689.png)

![image-20250525101425463](../assets/post-pics/image-20250525101425463.png)

![image-20250525101434234](../assets/post-pics/image-20250525101434234.png)

![image-20250525101518541](../assets/post-pics/image-20250525101518541.png)

![image-20250525101526164](../assets/post-pics/image-20250525101526164.png)

![image-20250525101900701](../assets/post-pics/image-20250525101900701.png)

![image-20250525101909077](../assets/post-pics/image-20250525101909077.png)

![image-20250525101921198](../assets/post-pics/image-20250525101921198.png)

## 半主机模式

单片机可以通过串口打印信息，printf 函数重定向后使用十分方便。

所谓重定向是指修改 printf 的底层函数，使 printf 打印到单片机的外设中。

#### 还有一个概念是半主机:

半主机是用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机。 例如，使用此机制可以启用 C 库中的函数，如 printf() 和 scanf()，来使用主机的屏幕和键盘，而不是在目标系统上配备屏幕和键盘。

这种机制很有用，因为开发时使用的硬件通常没有最终系统的所有输入和输出设备。 半主机可让主机来提供这些设备。

半主机是通过一组定义好的软件指令（如 SVC）来实现的，这些指令通过程序控制生成异常。 应用程序调用相应的半主机调用，然后调试代理处理该异常。 调试代理提供与主机之间的必需通信。

半主机接口对 ARM 公司提供的所有调试代理都是通用的。 在无需移植的情况下使用 RealView ARMulator® ISS、指令集系统模型 (ISSM)、实时系统模型 (RTSM)、RealView ICE 或 RealMonitor 时，会执行半主机操作。

标准库使用半主机模式，半主机是通过一组定义好的软件指令 （如 SVC）SVC 指令 （以前称为 SWI 指令）来实现的，这些指令通过程序控制生成异常。 应用程序调用相应的半主机调用，然后调试代理处理该异常。调试代理（这里的调试代理是仿真器）提供与主机之间的必需通信。也就是说使用半主机模式必须使用仿真器调试。

ARMv7 之前的 ARM 处理器使用 SVC 指令 （以前称为 SWI 指令）进行半主机调

用。 但是，如果要为 ARMv6-M 或 ARMv7-M （如 Cortex™-M1 或 Cortex-M3 处

理器）进行编译，请使用 BKPT 指令来实现半主机。

简单的来说，半主机模式就是通过仿真器实现开发板在电脑上的输入和输出。和半主机模式功能相同的是 ITM 调试机制。

---

下面开始介绍外设，所有外设在对应的 ST 参考手册中，都会给出外设的工作原理框图和寄存器配置说明（每一位代表什么）；但 HAL 库和 CubeMX 这样的工具就是为了隐藏硬件细节而开发出的工具，因此在使用 CubeMX+HAL 库开发的过程中，一般不会直接跟寄存器打交道，因此这部分只在需要用到时在手册中查阅相应的内容并且能看懂即可，不需要掌握每个外设具体的框图和寄存器配置。以下的外设介绍均略去了这部分。在被略去的部分中，值得一提的是，从时钟树中可见，每个外设都会从 AHB 上分出来的 APB1 或 APB2 上经过分频器拿到自己的时钟。

## GPIO

General Purpose Input Output，即通用输入输出端口，简称 GPIO

作用：负责采集外部器件的信息或者控制外部器件工作，即输入输出

1，不同型号，IO 口数量可能不一样，可通过选型手册快速查询

2，快速翻转，每次翻转最快只需要两个时钟周期（F1 最高速度可以到 50Mhz）

3，每个 IO 口都可以做中断

4，支持 8 种工作模式

IO 端口的输入或输出是由 GPIO 外设控制，我们称之为通用。IO 端口的输入或输出是由其它非 GPIO 外设控制，我们称之为复用。

![image-20250525221345903](../assets/post-pics/image-20250525221345903.png)

![image-20250525222540265](../assets/post-pics/image-20250525222540265.png)

![image-20250525102501897](../assets/post-pics/image-20250525102501897.png)

IO 引脚分布特点：按组存在、组数视芯片而定、每组最多 16 个 IO 引脚

![image-20250525102533746](../assets/post-pics/image-20250525102533746.png)

![image-20250525102552762](../assets/post-pics/image-20250525102552762.png)

![image-20250525102622221](../assets/post-pics/image-20250525102622221.png)

1，F1 在输出模式，禁止使用内部上下拉

F4/F7/H7 在输出模式，可以使用内部上下拉

2，不同系列 IO 翻转速度可能不同

各个寄存器的具体配置可查阅手册，此处略去

![image-20250525103433840](../assets/post-pics/image-20250525103433840.png)

![image-20250525103510518](../assets/post-pics/image-20250525103510518.png)

![image-20250525103523747](../assets/post-pics/image-20250525103523747.png)

![image-20250525103531554](../assets/post-pics/image-20250525103531554.png)

![image-20250525103550608](../assets/post-pics/image-20250525103550608.png)

![image-20250525103601040](../assets/post-pics/image-20250525103601040.png)

![image-20250525103614633](../assets/post-pics/image-20250525103614633.png)

## 中断

![image-20250525104025514](../assets/post-pics/image-20250525104025514.png)

![image-20250525104155650](../assets/post-pics/image-20250525104155650.png)

![image-20250525104206146](../assets/post-pics/image-20250525104206146.png)

![image-20250525104308718](../assets/post-pics/image-20250525104308718.png)

![image-20250525104359782](../assets/post-pics/image-20250525104359782.png)

![image-20250525215156265](../assets/post-pics/image-20250525215156265.png)

一个工程中，一般只设置一次中断优先级分组。

External(Extended) interrupt/event Controller，外部(扩展)中断事件控制器。包含 20 个产生事件/中断请求的边沿检测器，即总共：20 条 EXTI 线（F1）。

**中断和事件的理解：**

中断：要进入 NVIC，有相应的中断服务函数，需要 CPU 处理

事件：不进入 NVIC，仅用于内部硬件自动控制的，如：TIM、DMA、ADC

![image-20250525215250983](../assets/post-pics/image-20250525215250983.png)

每条 EXTI 线都可以单独配置：选择类型（中断或者事件）、触发方式（上升沿，下降沿或者双边沿触发）、支持软件触发、开启/屏蔽、有挂起状态位

![image-20250525215349949](../assets/post-pics/image-20250525215349949.png)

![image-20250525215453705](../assets/post-pics/image-20250525215453705.png)

![image-20250525215538053](../assets/post-pics/image-20250525215538053.png)

![image-20250525215558905](../assets/post-pics/image-20250525215558905.png)

![image-20250525215616738](../assets/post-pics/image-20250525215616738.png)

![image-20250525215702474](../assets/post-pics/image-20250525215702474.png)

```c
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
```

## 串口

基本概念：串行/并行，单工/半双工/全双工，同步/异步（同步通信共用同一时钟信号，异步通信没有时钟信号，通过在数据信号中加入起始位和停止位等一些同步信号）。

通信速率用比特率和波特率描述。比特率：每秒钟传送的比特数，单位 bit/s。波特率：每秒钟传送的码元数，单位 Baud。比特率 = 波特率 \* log2 M ，M 表示每个码元承载的信息量。二进制系统中，波特率数值上等于比特率。

![image-20250525220230842](../assets/post-pics/image-20250525220230842.png)

串口是串行通信接口的简称，是按位发送和接收的接口，如 RS-232/422/485 等

![image-20250525220327666](../assets/post-pics/image-20250525220327666.png)

![image-20250525220416833](../assets/post-pics/image-20250525220416833.png)

![image-20250525220429655](../assets/post-pics/image-20250525220429655.png)

![image-20250525220449868](../assets/post-pics/image-20250525220449868.png)

![image-20250525220533267](../assets/post-pics/image-20250525220533267.png)

Universal synchronous asynchronous receiver transmitter，通用同步异步收发器。Universal asynchronous receiver transmitter，通用异步收发器。USART/UART 都可以与外部设备进行全双工异步通信。

![image-20250525220803163](../assets/post-pics/image-20250525220803163.png)

![image-20250525221008963](../assets/post-pics/image-20250525221008963.png)

![image-20250525221140677](../assets/post-pics/image-20250525221140677.png)

![image-20250525221104297](../assets/post-pics/image-20250525221104297.png)

![image-20250525221149442](../assets/post-pics/image-20250525221149442.png)

![image-20250525221211855](../assets/post-pics/image-20250525221211855.png)

![image-20250525221242702](../assets/post-pics/image-20250525221242702.png)

![image-20250525221252460](../assets/post-pics/image-20250525221252460.png)

![image-20250525221300539](../assets/post-pics/image-20250525221300539.png)

![image-20250525222630243](../assets/post-pics/image-20250525222630243.png)

## IWDG 独立看门狗

![image-20250525224153239](../assets/post-pics/image-20250525224153239.png)

![image-20250525224210158](../assets/post-pics/image-20250525224210158.png)

![image-20250525224220007](../assets/post-pics/image-20250525224220007.png)

![image-20250525225436040](../assets/post-pics/image-20250525225436040.png)

```c
void HAL_IWDG_Refresh(&iwdg_handler);    /* 喂狗 */
```

![image-20250525231156932](../assets/post-pics/image-20250525231156932.png)

![image-20250525231204996](../assets/post-pics/image-20250525231204996.png)

## WWDG 窗口看门狗

![image-20250525231251007](../assets/post-pics/image-20250525231251007.png)

![image-20250525231418981](../assets/post-pics/image-20250525231418981.png)

![image-20250525231511287](../assets/post-pics/image-20250525231511287.png)

![image-20250525231532704](../assets/post-pics/image-20250525231532704.png)

![image-20250525231558114](../assets/post-pics/image-20250525231558114.png)

![image-20250525231606222](../assets/post-pics/image-20250525231606222.png)

![image-20250525231620895](../assets/post-pics/image-20250525231620895.png)

```c
void HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)
```

## 定时器

软件定时需要 CPU 死等实现，延时不精准且浪费资源。使用精准的时基，通过硬件的方式，实现定时功能。定时器就是计数器

![image-20250525232604368](../assets/post-pics/image-20250525232604368.png)

![image-20250525232611266](../assets/post-pics/image-20250525232611266.png)

![image-20250525232627190](../assets/post-pics/image-20250525232627190.png)

![image-20250525232711999](../assets/post-pics/image-20250525232711999.png)

## 关于 microlib

使用微库，将以更精简短小的 C 库替代标准 C 库，减小代码大小。MicroLib 是默认 C 库的备选库。它主要用于内存有限的嵌入式应用程序中。这些应用程序不在操作系统中运行。
如果你发现在 Keil RealView MDK 中使用 printf 函数，不能向串口输出信息，或者今后发现可以软件仿真，不能硬件仿真，MicroLib 提供了一个有限的 stdio 子系统，它仅支持未缓冲的 stdin、stdout 和 stderr。这样，即可使用 printf()来显示应用程序中的诊断消息。要使用高级 I/O 函数，就必须提供自己实现的以下基本函数，以便与自己的 I/O 设备（如串口）配合使用。为所有输出函数：fprintf()、printf()、fwrite()、fputs()、puts()、putc()和 putchar()等需要实现 fputc()函数。为所有输入函数：fscanf()、scanf()fread()、read()、fgets()、gets()、getc() 和 getchar()等需要实现 fgetc()函数。由于 MicroLib 进行了高度优化，以使代码变得很小。因此，MicroLib 不完全符合 ISO C99 库标准，仅提供有限的支持，不具备某些 ISO C 特性。并且其他特性具有的功能比默认 C 库少，MicroLib 与默认 C 库之间的

主要差异是：
（1）MicroLib 不支持 IEEE 754 关于二进制浮点算法标准，否则会产生不可预测的输出的结果，如 NaN、无穷大。
（2）MicroLib 中不支持的转换为%lc、%ls 和%a。
（3）MicroLib 进行了高度优化，以使代码变得很小。
（4）MicroLib 不支持与操作系统交互的所有函数，如 abort()、exit()、atexit()、clock()、time()、system()
和 getenv()。不能将 main()声明为带参数的，并且不能返回内容。
（5）不支持与文件指针交互的所有 stdio 函数，否则将返回错误。仅支持三个标准流：stdin、stdout
和 stderr。即不完全支持 stdio，仅支持未缓冲的 stdin、stdout 和 stderr。
（6）MicroLib 不提供互斥锁来防止非线程安全的代码。
（7）MicroLib 不支持宽字符或多字节字符串。如果使用这些函数，则会产生链接器错误。
（8）与 stdlib 不同，MicroLib 不支持可选择的单或双区内存模型。MicroLib 只提供双区内存模型，即单
独的堆栈和堆区。

## 数据手册概要

![image-20250523223622224](../assets/post-pics/image-20250523223622224.png)

芯片的基本参数包括：主频、FLASH 和 SRAM 容量、工作电压和最大电流、IO 引脚接入电压范围、单个 IO 引脚最大电流。除 GPIO 之外，特殊引脚包括电源引脚、晶振引脚、复位引脚、下载引脚、BOOT 引脚

最小系统

![image-20250523224746372](../assets/post-pics/image-20250523224746372.png)

![image-20250523224928295](../assets/post-pics/image-20250523224928295.png)

最小系统电路

![image-20250523225131075](../assets/post-pics/image-20250523225131075.png)

![image-20250523225142288](../assets/post-pics/image-20250523225142288.png)

![image-20250523225148946](../assets/post-pics/image-20250523225148946.png)

![image-20250523225156889](../assets/post-pics/image-20250523225156889.png)

![image-20250523225205340](../assets/post-pics/image-20250523225205340.png)

![image-20250523225214269](../assets/post-pics/image-20250523225214269.png)

调试：Call Stack 窗口：查看函数调用关系&局部变量，lWatch 窗口：查看函数首地址&变量值（可设置设置全局变量在被读或写后自动停止运行），lMemory 窗口：内存查看窗口（注意 M3/M4/M7 的内核是小端模式，内存的值需要倒着读），lPeripheral 窗口：查看寄存器的值（调试时，使用该功能可以确定配置寄存器是否有问题）。调试停止在断点处时，只是内核停止，外设会继续运行

## 正点原子探索者使用

![image-20250523174151786](../assets/post-pics/image-20250523174151786.png)

电阻屏电容屏、协议栈、排孔排针排母、怎么低价 SMT、怎么找 3D 封装

三轴磁力计芯片 ST480MC、音频编解码芯片 ES8388、自带 1MB 的 flash 的 MCU、1MB 的 SRAM 芯片 XM8A51216、16MB 的 spi flash 芯片、RS232 串口接口芯片、百兆网卡、光敏传感器芯片、各种接口芯片、CAN 接口芯片、LCD 接口芯片、RS485 接口芯片、以太网接口 RJ45（YT8512C 网络芯片）、电源输入 DC-DC 芯片、24C02 EEPROM 芯片（开发板板载的 EEPROM 芯片（U5），容量为 2Kb，也就是 256 字节。用于存储一些掉 电不能丢失的重要数据，比如系统设置的一些参数/触摸屏校准数据等。有了这个就可以方便的 实现掉电数据保存）、音频输入和输出芯片、扬声器，电位器、跳线帽的使用（如何做到选择功能的）、触摸按键 TPAD、复位和启动电路、单总线接口、红外接受传感器、有源蜂鸣器、光敏传感器、OLED 芯片、摄像头、喇叭（该喇叭由 MD8002A 单声道桥接音频功率放大器 IC 进行驱动）、USB 转串口芯片 CH340C、后备电池、USB-Host（OTG）和 USB-Slave、USB 串口和 UART 串口、JTAG 和 SWD 接口、TF 卡接口、wireless 模块 NRF24L01、温湿度传感器 DS18B20/DHT11

从广义上讲，“串行通信 ”和“串口通信 ”是同一个意思；狭义上讲串口通信 一般特指 UART 通信 （即常说的 COM 口），是最常见的一种串行通信方式。UART（Universal Asynchronous Receiver Transmitter）是一种异步串行通信协议。它通过两根线（TXD 和 RXD）逐位传输数据，是最经典的“串口”。USB 是一种 高速串行总线协议 ，属于串行通信的一种。但它不是简单的“串口”，而是复杂的协议栈（有分层结构、包格式、端点管理等）。USB 可以模拟串口（称为 USB 虚拟串口 ，如 CH340、CP2102 等芯片实现），但这只是其中一种应用。UART 和 USB 的本质不同，硬件实现机制完全不同

![image-20250523200128737](../assets/post-pics/image-20250523200128737.png)

STM32 中的 USART/SPI/I2C 属于标准的串行通信外设；USB OTG/FS/HS 则是完全独立的一套控制器，有专属的寄存器、中断、DMA 等。所以它们被设计为 不同的外设模块 ，不能混用。

RS485 和 CAN 的终端电阻；CAN 通信的时候，必须 CANH 接 CANH，CANL 接 CANL；RS485 通信的时候，必须 A 接 A，B 接 B。UART 则要 RX 和 TX 互相接。

- NRF24L01 是 Nordic Semiconductor 公司推出的一款 低成本、低功耗、2.4GHz ISM 频段的无线收发器芯片 。使用 SPI 接口 与主控芯片（如 STM32）通信。
- SDIO （Secure Digital Input Output）是 SD 卡标准的一个扩展协议，允许 SD 接口不仅用于存储（SD 卡），还可以连接输入输出设备（如 Wi-Fi、蓝牙、摄像头等）。在嵌入式系统中，SDIO 是一个高速并行接口，常用于高速读写 TF 卡/SD 卡。当我们说“用 SDIO 方式驱动 TF 卡”，指的是：使用 STM32 或其他 MCU 上的 SDIO 控制器 来与 TF 卡通信。这种方式比普通的 SPI 方式更快（最高可达 48MHz 甚至更高），适合大容量、高速读写场景。TF 卡本质上就是 microSD 卡，可以通过 SDIO 接口进行高速访问。

怎么找实现某个功能性能比较好的芯片，以及它们的使用，怎么画到板子上，驱动怎么写，程序中怎么用。汇编和 ARM 内核的东西，指令集，LVGL、LWLP 等等中间件，操作系统

RS232 是一种串行通信标准，通常使用 9 针接口（DB9）。虽然理论上可以使用更多或更少的引脚，但常见的 RS232 接口包含 9 根线。这些线主要用于实现全双工通信、握手协议（如 RTS/CTS）、设备状态监控等功能。RS232 的设计初衷是支持点对点通信，因此需要较多的信号线来确保通信的可靠性和稳定性。RS485 是一种多点通信标准，通常使用两根线（差分信号线）：A 和 B（也称为+和-）。它通过差分信号传输数据，具有抗干扰能力强、支持长距离通信的特点。RS485 的设计目的是支持多点通信，允许多个设备共享同一对通信线，因此不需要像 RS232 那样复杂的握手和状态信号线。

在系统存储器启动模式下，STM32 的启动代码会从 系统存储器（System Memory） 开始执行。系统存储器是 STM32 内置的一小块 ROM（只读存储器），通常包含一个 引导加载程序（Bootloader） 。引导加载程序是一个预烧录在系统存储器中的小程序，其主要功能是：检测外部设备（如 USB、UART、SWD 等）是否连接。如果检测到外部设备连接，引导加载程序会尝试通过该设备接收新的固件代码，并将其写入用户闪存（FLASH）中。如果没有检测到外部设备连接，则跳转到用户闪存中的应用程序开始运行。

各种电平转换芯片和原理，常见的电平标准

FlyMcu 是一个用于通过串口给 STM32 系列单片机烧录程序 的免费工具，由国内开发者制作。它基于 STM32 的串口 Bootloader 功能 （即 UART ISP 模式）。DTR 和 RTS 是 串口通信中的控制信号线 ，属于 RS232 接口标准的一部分，常见于 USB 转 TTL 模块。在实际使用中，尤其是配合 STM32 的串口下载功能时，这两个信号常被用来模拟按键或控制 BOOT 引脚 ，实现自动下载功能。DTR 低电平复位，RTS 高电平进 bootloader 的意思是，低电平脉冲会使 STM32 复位一次 ，相当于你手动按下复位键，让 STM32 进入统一的状态，准备进入 Bootloader 模式。STM32 有两种启动模式，由 BOOT0 和 BOOT1 引脚决定 。默认情况下，我们想让它从系统存储器启动（Bootloader），就需要把：

- `BOOT0 = 1`
- `BOOT1 = 0`

但如果你不想每次都手动拨动跳线帽或者按键设置 BOOT 引脚，FlyMcu 提供了一个替代方法：使用 RTS 引脚来控制 BOOT0 引脚。这样就可以在软件中控制 STM32 是从用户 Flash 启动，还是进入 Bootloader 模式。

ISP 是 In-System Programming 的缩写，表示“在系统编程”。在 STM32 中，ISP 模式是指通过外部接口（如 UART、USB、SWD 等）对芯片内部的 Flash 进行编程或更新固件的过程。STM32 内置了一个 Bootloader （引导加载程序），支持多种 ISP 模式：UART ISP ：通过串口下载程序、USB ISP ：通过 USB 接口下载程序、SWD ISP ：通过 SWD 接口下载程序。在 UART ISP 模式下，STM32 需要进入 Bootloader 模式 ，而不是直接运行用户程序。BOOT0=1,BOOT1=0 即从系统存储器（bootloader）中启动

PHY 是 Physical Layer （物理层）的缩写。在网络通信中，PHY 芯片负责处理 物理层协议 ，即与硬件相关的信号传输和接收。 在嵌入式系统中，MCU（如 STM32F4）通常只提供 MAC 层（Media Access Control） 功能，而 PHY 层 的功能需要通过外接 PHY 芯片来实现。PHY 芯片负责与实际的网络介质（如双绞线、光纤等）进行通信，而 MAC 芯片则负责管理数据包的发送和接收。

LCD （Liquid Crystal Display）是指液晶显示器。它是电子设备中常用的显示屏幕，通过控制液晶分子的排列来显示图像或文字。LCD 广泛应用于各种设备，如手机、电脑、电视、仪表盘等。

RJ45 （Registered Jack 45）是一种网络接口标准，通常用于以太网通信。它是一个 8 针的连接器，常用于局域网（LAN）和其他基于以太网的网络设备。

MIC （Microphone）是指麦克风，用于捕捉声波并将其转换为电信号。在图中，MIC 接口用于连接外部麦克风，实现录音功能。

单总线 （1-Wire）是一种由 Dallas Semiconductor（现为 Maxim Integrated）开发的通信协议，使用一根数据线和一根地线进行通信。它是一种简单的串行通信协议，支持多个设备共享同一根数据线。常见的单总线外设包括温度传感器（如 DS18B20）、湿度传感器、存储器（如 DS2433）等。单总线的主要优点是节省硬件资源，因为多个设备可以共享同一根数据线，减少了布线复杂度。它适用于低速、低成本的传感器网络，特别适合物联网（IoT）应用。

USB UART 是一种将 USB 接口转换为 UART（通用异步收发传输器）接口的模块或芯片。它允许通过 USB 端口进行串行通信。USB Slave 模式是指设备作为 USB 从设备工作（USB 通信），需要主机（如计算机）发起通信请求。USB Host 模式是指设备作为 USB 主机工作，可以主动发起通信请求，控制其他 USB 设备。开发板总共板载了 2 个 Type C USB 头，一个（USB_UART）用于 USB 转串口，连接 CH340C 芯片；另外一个（USB_SLAVE）用于 STM32 内带的 USB。

TF 卡 （TransFlash Card）也称为 microSD 卡，是一种小型化的闪存卡，常用于移动设备（如手机、相机）中。SD 卡 （Secure Digital Card）是一种较早的闪存卡标准，体积较大，常用于数码相机、便携式媒体播放器等设备。尺寸 ：TF 卡比 SD 卡更小，更适合小型设备。大多数 TF 卡可以通过适配器插入 SD 卡槽，但 SD 卡无法直接插入 TF 卡槽。

KEY_UP 具有唤醒功能（从低功耗模式下唤醒），该按键连接到 STM32 的 WAKE_UP（PA0）引脚，可用于待机模式下的唤醒， 在不使用唤醒功能的时候，也可以做为普通按键输入使用。

I2S_LRCK 和 I2S_SCLK 是 I²S（Inter-IC Sound）总线协议 中的核心时钟和控制信号。是一种 专为数字音频设备之间传输音频数据 而设计的串行通信接口标准。

FSMC 是 Flexible Static Memory Controller，即可变静态存储控制器，是 STM32 中一个 通用并行总线接口。它可以像访问内存一样去访问外部设备，支持多种存储器和接口设备，用于驱动大屏 TFT-LCD（如带 8080 并口的屏幕），连接外部 SRAM 或 Flash 存储芯片，与 FPGA、AD/DA 模块通信，扩展外部存储空间（适用于资源紧张的嵌入式系统）。在 STM32 上使用 FSMC 接口驱动 ILI9341 屏幕，可以实现高速图像刷新，常用于图形界面开发。

RMII 是一种用于以太网通信的 精简版 MAC-PHY 接口协议 。是 MII（Media Independent Interface）的简化版本，减少了引脚数量，便于集成。STM32 连接以太网 PHY 芯片（如 LAN8720、DP83848）

DCMI 是 STM32 提供的一个专门用于 接收来自图像传感器的数据 的接口。它是一个 并行接口 ，支持多种标准的 CMOS 图像传感器。接收 OV7670、OV2640、MT9V034 等图像传感器数据

![image-20250523211149202](../assets/post-pics/image-20250523211149202.png)

可以学习的设计：

通过跳线帽来选择功能或允许外接，对于选择功能，可以理解为单刀多掷开关，用跳线帽实现，MCU 的引脚理解为开关的公共端，而外设芯片为可供开关选择的另一侧。允许外接同理，即将外设芯片的引脚通过排针引出，MCU 也通过排针引出，自己板子用时插上跳线帽，外接给别的板子时拔掉跳线帽用排针接线即可。

后备区域的供电接口(BAT)，可安装 CR1220 电池（默认安装了），可以用来给 STM32 的后备区域提供能量，在外部电源断电的时候，维持后备区域数据的存储，以及 RTC 的 运行。

外扩了 flash 和 SRAM

RS232 的公头为 COM3、母头为 COM2

## 调试接口

ATK-DAP 是正点原子（ALIENTEK）公司推出的一款调试器/下载器，全称可能是 ALIENTEK DAP Link ，它是一个基于 CMSIS-DAP 协议实现的硬件调试工具。MDK（Microcontroller Development Kit） 是由 Keil 公司开发的一套集成开发环境（IDE），主要用于 ARM 架构的微控制器开发。IAR Embedded Workbench for ARM（简称 IAR EWARM） 是 IAR Systems 提供的另一款主流嵌入式开发 IDE，专为 ARM 架构设计。两个 IDE 各有自己的编译器。JTAG（Joint Test Action Group） 是一种标准测试协议，最初用于测试印刷电路板上的集成电路互连情况，后来被广泛用于嵌入式系统的调试和烧录。SWD（Serial Wire Debug） 是 ARM 公司提出的一种替代 JTAG 的调试接口，专为嵌入式系统设计。“仿真接口”指的是调试器（如 ATK-DAP、J-Link、ST-LINK）与目标 MCU 之间通信所使用的物理接口，根据目标芯片和调试器选择使用哪种接口。“仿真接口”是指调试器（Debugger）与目标 MCU 之间通信的物理和逻辑通道。它决定了调试器如何访问 MCU 的寄存器、内存、断点等功能。DAP（Debug Access Port） 是 ARM CoreSight 架构中的一个模块，允许调试器通过 SWD 或 JTAG 访问内核和外设寄存器。CMSIS-DAP（Cortex Microcontroller Software Interface Standard - Debug Access Port） 是 Arm 提出的一个开源调试接口协议，用于实现通用的调试适配器。keil 的 debugger 的 settings 中，可以在 Programming Algorithm 中查到 flash 容量。

## 中间件

emWin、LVGL、lwIP、uC/OS、FreeRTOS 都是嵌入式开发中非常重要的中间件或操作系统组件。emWin 全称 SEGGER emWin，是用于嵌入式系统的图形用户界面（GUI）库，需要商业授权；LVGL 是开源嵌入式图形库，适用于资源有限的嵌入式设备，完全开源；lwlP 为一个轻量级的 TCP/IP 协议栈，适用于嵌入式系统，完全开源；uC/OS-II / uC/OS-III 为硬实时内核（RTOS），需要商业授权；FreeRTOS 全称 Free Real-Time Operating System，为轻量级硬实时内核。

## 启动文件解析

startup_stm32f103xe.s

STM32 启动文件由 ST 官方提供，在官方的固件包里。启动文件由汇编编写，是系统上 电复位后第一个执行的程序。

启动文件主要做了以下工作：

1. 初始化堆栈指针 SP = \_initial_sp
2. 初始化程序计数器指针 PC = Reset_Handler
3. 设置堆和栈的大小
4. 初始化中断向量表
5. 配置外部 SRAM 作为数据存储器（可选）
6. 配置系统时钟，通过调用 SystemInit 函数（可选）
7. 调用 C 库中的 \_main 函数初始化用户堆栈，最终调用 main 函数

![image-20250523100456842](../assets/post-pics/image-20250523100456842.png)

内存空间的开辟：设置内存大小，设置内存空间段名、是否初始化、读写权限、字节对齐，后分配内存，标记结束位置。内存对齐一方面是满足处理器架构要求，ARM Cortex-M 系列内核（如 Cortex-M3/M4/M7）的栈指针（SP）必须指向一个 8 字节对齐 的地址，这是 ARM 架构规范所规定的；另一方面，现代处理器为了提升性能，往往会对数据访问有对齐要求。例如，访问一个双字（64 位）类型的数据时，如果地址不是 8 字节对齐的，可能需要两次内存访问，影响性能。此外，在使用 FPU（浮点单元）时，某些浮点操作要求栈帧必须 8 字节对齐，否则会导致错误或崩溃。

栈空间的开辟：栈是从高往低生长，所以结束地址就是栈顶地址。栈顶地址可通过.map 文件中的 initial_sp 查看。比如定义 Stack_Size 的大小是 0x00000400，通过 map 文件看到栈顶地址 initial_sp 的 地址是 0x20000788，那栈底地址就是 0x20000388。栈顶地址 0x20000788 到栈底地址 0x20000388 的内存大小刚好就是 Stack_Size 的大小。每使用一个栈空间地址，栈顶地址\_\_initial_sp 就减一。栈主要用于存放局部变量，函数形参等，属于编译器自动分配和释放的内存，栈的大小不能超过内部 SRAM 的大小。如果程序出现了莫名其妙的错误， 并进入了 HardFault 的时候，你就要考虑下是不是栈空间不够大，溢出了的问题。

堆空间的开辟：堆和栈的生长方向相反的，堆是由低向高生长，而栈是从高往低生长。堆主要用于动态内存的分配，像 malloc()、calloc()和 realloc()等函数申请的内存就在堆上面。堆中的内存一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统 回收。

PRESERVE8：指示编译器按照 8 字节对齐。

THUMB：指示编译器之后的指令为 THUMB 指令。 在 `THUMB` 指令之前（即复位向量表部分），使用的仍然是 Thumb 指令集 ，但这是通过一种特殊机制实现的 —— 向量表中的地址最低位为 1（LSB=1）表示进入 Thumb 模式 。

ARM 处理器在启动时默认处于 Thumb 状态（Thumb mode） ，所以 `THUMB` 指令只是为了告诉汇编器“我接下来用的是 Thumb 指令”，并不是切换指令集的指令。Cortex-M 系列（如 STM32 使用的 M3、M4、M7 等）只支持 Thumb 模式 ，不支持传统的 ARM 指令集。ARM Cortex-M 内核在上电复位后自动进入 Thumb 状态 ，这意味着你写的任何启动代码都必须是 Thumb 指令。但是，在复位向量表中，我们通常写的是地址。这些地址指向的函数，其最低位（LSB）必须为 1 ，以告诉 CPU：“这个地址是 Thumb 代码”。因此，即使没有写 `THUMB` 指令，向量表指向的代码也必须是 Thumb 代码 。THUMB 伪指令只是告诉汇编器（如 armasm 或 GNU as）：“下面的代码使用 Thumb 指令集”，让汇编器正确地进行指令编码和语法检查。它并不会生成实际的机器码（不是一条 CPU 执行的指令），只是给汇编器看的提示信息。如果你使用的是 GCC 工具链（如 STM32CubeIDE），通常不需要手动加 `+1`，链接器会自动处理地址的 LSB 设置。

中断向量表定义：当内核响应了一个发生的异常后，对应的异常服务例程(ESR)就会执行。为了决定 ESR 的入口地址， 内核使用了向量表查表机制。向量表其实是一个 WORD（32 位整数）数组，每个下标对应一种异常，该下标元素的值则是该 ESR 的入口地址。向量表在地址空间中的位置是可以设置的，通过 NVIC 中的一个重定位寄存器来指出向量表的地址。在复位后，该寄存器的值为 0。因此，在地址 0 （即 FLASH 地址 0） 处必须包含一张向量表，用于初始时的异常分配。这里有个另类：地址 0x0000 0000 并 不是什么入口地址，而是给出了复位后 MSP 的初值。从代码上看，向量表中存放的都是中断服务函数的函数名，所以 C 语言中的函数名对 芯片来说实际上就是一个地址。

DCD：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。

复位程序：SystemInit 是一个标准的库函数， 在 system_stm32f1xx.c 文件中定义，主要作用是配置系统时钟、还有就是初始化 FSMC/FMC 总线上外挂的 SRAM(可选)，前面说配置外部 SRAM 作为数据存储器（可选）就是这个。 把 main 的地址给 R0。main 是一个标准的 C 库函数，主要作用是初始化用 户堆栈和变量等，最终调用 main 函数去到 C 的世界。这就是为什么我们写的程序都有一 个 main 函数的原因，如果不调用\_\_main，那么程序最终就不会调用我们 C 文件里面的 main，也就无法正常运行。LDR、BLX、BX 是内核的指令。`BLX` 指令会根据 `R0` 中的地址跳转到 `SystemInit` 函数，并执行该函数。`_main` 是由编译器自动生成的函数，其作用是为程序的启动和运行做好准备。\_\_main 是编译系统提供的一个函数，负责完成库 函数的初始化和初始化应用程序执行环境，最后自动跳转到 main()。 加载地址是程序在存储介质 flash 中存放的地址，程序编译完成后，会生成一个可执行文件（比如 `.elf` 或 `.bin`），烧写到 Flash 中时，这些代码和数据就位于这个“加载地址”。运行地址是程序 实际运行时需要被放置的地址，有些段（比如 RW 段）必须在 RAM 中运行，因为它们包含可修改的数据，所以这些段在 Flash 中只是“加载”用的，运行前要复制到 RAM 中去。

中断服务程序：在启动文件代码中，已经把我们所有中断的中断服务函数写好了，但都是声明为弱定义， 所以真正的中断服务函数需要我们在外部实现。如果我们开启了某个中断，但是忘记写对应的中断服务程序函数又或者把中断服务函数 名写错，那么中断发生时，程序就会跳转到启动文件预先写好的弱定义的中断服务程序中，并且在 B 指令作用下跳转到一个‘.’中，无限循环。这里的系统异常中断是内核的，外部中断是外设的。

ALIGN 表示对指令或者数据的存放地址进行对齐，一般需要跟一个立即数，缺省表示 4 字节对齐。要注意的是，这个不是 ARM 的指令，是编译器的。

用户堆栈初始化：判断是否定义了 MICROLIB。关于 MICROLIB 这个宏定义，我们是在 KEIL 里面配置，接下来进行堆栈空间初始化，堆是从低到高生长，栈是从高到低生长，是两个互相独立 的数据段，并且不能交叉使用。MicroLIB 是 MDK 自带的微库，是缺省 C 库的备选库，MicroLIB 进行了高度优化使得 其代码变得很小，功能比缺省 C 库少。MicroLIB 是没有源码的，只有库。

Cortex-M3 内核复位后的起始地址和中断向量表的位置可以被重映射。充映射的方法是通过启动模式的 选择，有以下 3 种情况: 1、 通过 boot 引脚设置可以将中断向量表定位于 SRAM 区，即起始地址为 0x2000000， 同时复位后 PC 指针位于 0x2000000 处； 2、 通过 boot 引脚设置可以将中断向量表定位于 FLASH 区，即起始地址为 0x8000000， 同时复位后 PC 指针位于 0x8000000 处； 3、 通过 boot 引脚设置可以将中断向量表定位于内置 Bootloader 区，本文不对这种情 况做论述。 Cortex-M3 内核规定，起始地址必须存放堆顶指针，而第二个地址则必须存放复位中断 入口向量地址，这样在 Cortex-M3 内核复位后，会自动从起始地址的下一个 32 位空间取出 复位中断入口向量，跳转执行复位中断服务程序。 启动模式不同，启动的起始地址是不一样的，下面我们以代码下载到内部 FLASH 的情 况举例，即代码从地址 0x0800 0000 开始被执行。 我们知道的复位方式有三种：上电复位，硬件复位和软件复位。当产生复位，并且离开 复位状态后，CM3 内核做的第一件事就是读取下列两个 32 位整数的值： （1）从地址 0x0800 0000 处取出堆栈指针 MSP 的初始值，该值就是栈顶地址。 （2）从地址 0x0800 0004 处取出程序计数器指针 PC 的初始值，该值指向复位后执行 的第一条指令。我们看看战舰开发板 HAL 库例程的实验 1 跑马灯实验中，取出的 MPS 和 PC 的值是多 少，方法如图 3.2 所示。

![image-20250523145032494](../assets/post-pics/image-20250523145032494.png)

由图 3.2 可以知道地址 0x08000000 的值是 0x20000788，地址 0x08000004 的值是 0x080001CD，即堆栈指针 SP = 0x20000788，程序计数器指针 PC = 0x080001CD。因为 CM3 内核是小端模式，所以倒着读。（CM4 默认也是小端模式）。在 CM3 内核中，0 地址处提供 MSP 的初始值，然后就是向量表（向量表在以后还可以被 移至其它位置）。向量表中的数值是 32 位的地址，而不是跳转指令。向量表的第一个条目 指向复位后应执行的第一条指令，就是 Reset_Handler 这个函数。下面继续以战舰开发板 HAL 库例程的实验 1 跑马灯实验为例，代码从地址 0x0800 0000 开始被执行，讲解一下系统启动， 初始化堆栈、MSP 和 PC 后的内存情况。

![image-20250523145413879](../assets/post-pics/image-20250523145413879.png)

因为 CM3 使用的是向下生长的满栈，所以 MSP 的初始值必须是堆栈内存的末地址加 1。 举例来说，如果你的栈区域在 0x20000388‐0x20000787 之间，那么 MSP 的初始值就必须 是 0x20000788。 向量表跟随在 MSP 的初始值之后——也就是第 2 个表目。 R15 是程序计数器，在汇编代码中，可以使用名字“PC”来访问它。ARM 规定：PC 最低两位并不表示真实地址，最低位 LSB 用于表示是 ARM 指令（0）还是 Thumb 指令（1）因为 CM3 主要执行 Thumb 指令，所以这些指令的最低位都是 1（都是奇数）。因为 CM3 内 部使用了指令流水线，读 PC 时返回的值是当前指令的地址+4。

如果向 PC 写数据，就会引起一次程序的分支（但是不更新 LR 寄存器）。CM3 中的 指令至少是半字对齐的，所以 PC 的 LSB 总是读回 0。然而，在分支时，无论是直接写 PC 的值还是使用分支指令，都必须保证加载到 PC 的数值是奇数（即 LSB=1），表明是在 Thumb 状态下执行。倘若写了 0，则视为转入 ARM 模式，CM3 将产生一个 fault 异常。 正因为上述原因，图 3.3 中使用 0x080001CD 来表达地址 0x080001CC。当 0x080001CD 处的指令得到执行后，就正式开始了程序的执行（即去到 C 的世界）。所以在 此之前初始化 MSP 是必需的，因为可能第 1 条指令还没执行就会被 NMI 或是其它 fault 打断。MSP 初始化好后就已经为它们的服务例程准备好了堆栈。

## 内存映射文件解析

map 文件主要在永华代码时会用到。

MDK 编译工程，会生成一些中间文件（如.o、.axf、.map 等），最终生成 hex 文件，以 便下载到 MCU 上面执行

![image-20250523172928060](../assets/post-pics/image-20250523172928060.png)

可重定向是指该文件包含数据/代码，但是并没有指定地址，它的地址可由后续链接 的时候进行指定。 不可重定向是指该文件所包含的数据/代码都已经指定地址了，不能再改变。

.o 文件，它是由编译器编译.c/.s 文件时所产生的可重定向对象文件，其文件名同.c/.s 文 件一模一样，只是后缀为.o。所以，我们看到.o 就应该想到与之对应的.c 或者.s 文件，我们 在分散加载里面经常会用到.o 文件。 .axf 文件，它是由 armlink 链接器，将整个工程参与编译的.o 文件链接成一个可执行对 象文件，它是不可重定向的。有了该文件，我们就可以用仿真器来下载到 MCU 进行仿真调 试了。注意：各类仿真器，在进行下载调试的时候，都是使用的.axf 文件。 .hex 文件，它是由.axf 转换而来的一个可执行对象文件。.hex 文件和.bin 文件的区别 是：.bin 文件不含地址信息，全部都是可执行代码；而.hex 文件则是包含地址信息的可自行 代码。同样的.bin 文件也是由.axf 文件转换而来的。我们在使用 ISP 软件进行程序下载的时 候，一般使用的是.hex 文件，由 ISP 软件解析.hex 文件包含的地址信息来实现程序下载。而 我们在进行 BootLoader 升级的时候，一般使用.bin 文件，地址由 Bootloader 程序指定。 .htm 文件，它是编译器在编译代码的时候生成的一个列表文件，包含了整个工程的静 态调用图，最大的用处就是可以查看栈深度（最小深度），方便设置栈大小。不过需要注意的是，这里的最大栈深度仅仅是最低要求（静态栈），因为它并没有统计 无栈深的函数（用内存管理）、递归函数、以及无法追踪的函数（函数指针）等所包含的栈 （Stack）。 不过它给我们指明了最低需求，我们在分配栈深度的时候，就可以参考这个值来做设置， 一般不低于静态栈的 2 倍。

.map 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过.map 文 件，我们可以知道整个工程的函数调用关系、FLASH 和 RAM 占用情况及其详细汇总信息， 能具体到单个源文件（.c/.s）的占用情况，根据这些信息，我们可以对代码进行优化。.map 文件可以分为以下 5 个组成部分： 1， 程序段交叉引用关系（Section Cross References） 2， 删除映像未使用的程序段（Removing Unused input sections from the image） 3， 映像符号表（Image Symbol Table） 4， 映像内存分布图（Memory Map of the image） 5， 映像组件大小（Image component sizes）

为了更好的分析 map 文件，我们先对需要用到的一些基础概念进行一个简单介绍，相 关概念如下： ● Section：描述映像文件的代码或数据块，我们简称程序段 ● RO：Read Only 的缩写，包括只读数据（RO data）和代码（RO code）两部分内容， 占用 FLASH 空间 ● RW：Read Write 的缩写，包含可读写数据（RW data，有初值，且不为 0），占用 FLASH （存储初值）和 RAM（读写操作） ● ZI：Zero initialized 的缩写，包含初始化为 0 的数据（ZI data），占用 RAM 空间。 ● .text：相当于 RO code ● .constdata：相当于 RO data ● .bss：相当于 ZI data ● .data：相当于 RW data

---

STM32 命名规则

![image-20250522234549019](../assets/post-pics/image-20250522234549019.png)

![image-20250523094538249](../assets/post-pics/image-20250523094538249.png)

![image-20250523094709198](../assets/post-pics/image-20250523094709198.png)

![image-20250523094749747](../assets/post-pics/image-20250523094749747.png)

![image-20250523094912550](../assets/post-pics/image-20250523094912550.png)

---

## 外设

摇杆实质上是电位器，摇杆处于不同位置时输出不同电压，注意需要保证模块输入电压正常，否则测得的电压值也会有偏差。

摇杆一般使用 ADC 读取输出的模拟电压，根据摇杆内阻计算确定 ADC 采样时间。

舵机由直流电机、齿轮减速箱、编码器（内含旋转电阻/电位器）和控制板组成，控制板采集电位器的输出电压得到角度反馈。绝大部分舵机使用 50Hz（周期 20ms）的 PWM 信号进行控制，占空比 2.5%和 12.5%分别对应最小旋转角度和最大旋转角度（即 500us 和 2500us）。

![f73542f65c9b55a11d2b1f600e3219c8](../assets/post-pics/f73542f65c9b55a11d2b1f600e3219c8.gif)

SG90 为最常见的舵机，塑料齿扭矩小；MG90 在此基础上使用金属齿；MG996 使用金属齿且扭矩更大。360° 舵机就是普通舵机减去编码器，不同的高电平持续时间对应旋转速度而不是角度。

直流电机对外的接口为正负两极，输入电压越高转速越快，调换极性可实现反转。

驱动电机需要的电流较大，MCU 无法驱动；电机旋转或手动旋转产生的反电动势产生的电流也较大，直接输入 MCU 也有可能烧坏芯片，因此需要电机驱动。

以 DRV8833 电机驱动为例，一颗 DRV8833 可驱动两个直流电机

![DRV8833](../assets/post-pics/DRV8833.png)

| IN1  | IN2  | OUT1   | OUT2   | 运行情况                                                                                                         |
| ---- | ---- | ------ | ------ | ---------------------------------------------------------------------------------------------------------------- |
| HIGH | LOW  | HIGH   | LOW    | 正转                                                                                                             |
| LOW  | HIGH | LOW    | HIGH   | 反转                                                                                                             |
| HIGH | HIGH | LOW    | LOW    | 相当于电机两端短路，电流慢衰减，反电动势磁场与定子磁场相互作用，电机快速刹停                                     |
| LOW  | LOW  | 高阻态 | 高阻态 | 芯片会将 OUT1 和 OUT2 输出反接，电流瞬间被释放掉（电流快衰减），电机两端为断路（高阻态），电机由于摩擦力慢慢停止 |

将高电平换成 PWM 信号可以快衰减电流控制转速，用于需要快速响应的场景，占空比越高转速越快

将低电平换成 PWM 信号可以慢衰减电流控制转速，用于需要平稳运行降低噪声的场景，占空比越低转速越快

其它常用的直流电机驱动芯片还有 L298N、TB6612 等，查阅对应资料可知其控制电机的方式，一般使用 MCU 的 GPIO 和 PWM 即可控制电机转向和转速。

参考资料

https://blog.csdn.net/sxstj/article/details/132106959

https://blog.csdn.net/weixin_43002939/article/details/130159073

编码器由带磁铁的码盘和霍尔元件组成，磁铁 N 极靠近元件产生高电平，S 极靠近元件产生低电平；码盘旋转在霍尔元件测量下产生脉冲信号，采集脉冲信号就可测得转过的距离，除以时间即可获得转速。

编码器的线数是指转过一圈产生的脉冲数，由码盘上的磁极对数决定。常用的编码器位增量式旋转编码器，有 AB 两相，两相脉冲信号由于霍尔元件的摆放位置，相位相差 90°，通过检测一相信号在上升/下降沿时，另一相为高电平/低电平，便可判断旋转方向。

![encoder111](../assets/post-pics/encoder111.png)

STM32 MCU 的定时器具有编码器接口模式，编码器两相分别接到定时器的 T1 和 T2 上就可以进行计数。单相计数时，一个脉冲会被计数两次，两相计数时，一个脉冲则会被计数四次。

![encoder222](../assets/post-pics/encoder222.png)

参考资料：

https://www.bilibili.com/video/BV1f4421U7Uj/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468

https://www.bilibili.com/video/BV1wN4y1D7LR/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468

https://www.bilibili.com/video/BV16x4y1M7EN/?spm_id_from=333.788.videopod.episodes&vd_source=1d0891b41fe4e23dbf197eaf61dfa468&p=15

步进电机基于电磁铁原理，其角度和角速度分别受控制脉冲的数量和频率控制，可以从源头上很好地控制输出。转子为永磁体，定子绕组产生矢量磁场，控制绕组的通电顺序可控制矢量磁场的方向，从而带动转子旋转。每输入一个电脉冲，转子旋转一个步距角，即最小旋转单位。

![step motor111](../assets/post-pics/step motor111.png)

步进电机分为单极性和双极性，极性指的是有几种电流流向。单极性步进电机一个电极上有两个绕组，一个绕组通电时，产生一个北极磁场； 另一个绕组通电，则产生一个南极磁场，电流方向唯一（由公共端决定电流方向）。双极性步进电机一个电极只有一个绕组，绕组电流方向决定产生的磁极方向。步进电机的相数是指产生不同对 NS 磁场的激磁线圈对数，可以理解为线圈的组数，两相电机步距角 1.8°，三相电机步距角 1.5°。步进电机的拍数是指完成一个磁场周期性变化需要的脉冲数或导电状态数。定位力矩是指不通电状态下电机转子自身的锁定力矩。静力矩是指通电不旋转状态下电机转子的锁定力矩。

![step motor222](../assets/post-pics/step motor222.png)

改变定子电流的比例，可以改变转子在一个整步中的不同位置，也就是细分的原理，细分提高了步进电机旋转的流畅度和精度。步进电机的精度大约为步距角的 3~5%，且不会累计。另外，其转矩与转速成反比。步进电机在低速时可以启动，高速时不会启动，即存在空载启动频率（最大脉冲频率），驱动信号高于这个频率会产生丢步或堵转。

步进电机可由方波数字信号驱动，对 MCU 而言可由 GPIO 或 PWM 实现。

28BYJ48 为单极性四相八拍式减速型永磁式步进电机，其最大外径 28mm，减速比 64:1，步距角(5.624/64)°，转一周所需脉冲数为 4096。该电机可由 ULN2003 芯片，该芯片由七个 NPN 达林顿管组成，是高电压、大电流复合晶体管阵列，用于放大电流提高驱动能力。

参考资料

https://doc.embedfire.com/motor/motor_tutorial/zh/latest/basis_part/stepper_motor.html

---

直流电机电机原理，见自动控制元件直流电机部分。

- 有刷直流电机用于不要求长寿命、高可靠性的作业环境。
- 无刷直流电机：简称 BLDC，噪声小且更轻巧。BLDC 的转子是永磁体，定子是磁铁，通电后线圈成为电磁铁。

![Motor1](../assets/post-pics/Motor1.png)

何时给那阿哥线圈通电励磁，是电子调速器的工作

- 异步电机/感应电机：定子是三线圈绕组，输入三相交流电产生旋转磁场，磁场旋转的速度称为同步速度。变化的磁场在回路中产生感应电动势，载流回路受到安培力作用，带动转子在磁场中旋转

![Motor2](../assets/post-pics/Motor2.png)

在感应电机中，用鼠笼式的机械结构来代替回路，鼠笼上的栅条与端环构成闭合回路，产生感应电流。

![Motor3](../assets/post-pics/Motor3.png)

![Motor4](../assets/post-pics/Motor4.png)

转子速度永远跟不上磁场的旋转速度，以略低于同步速度的速度旋转

异步电机不需要永磁体、电刷、换向器或位置传感器，可以通过控制输入电源的频率来调速（旋转磁场的速度正比于输入电源的频率）。

感应电机也可以由原动机驱动，作发电机使用，此时旋转磁场的速度会小于转子速度

- 步进电机

转子由永磁体构成，定子为通电线圈，作为电磁铁。步进电机一般有 50~100 个电磁铁，每个磁极为电机轴提供了一个自然的停止点，使得步进电机可以在没有位置反馈的情况下进行精准定位，且磁极越多定位越精准，即步进电机可以在开环系统中工作。一个脉冲信号对应一个步距角的转动，精确定位电机只需发送正确数量的脉冲即可。步进电机的转子上通常由多达 200 个齿，或电机轴旋转一周需要 200~400 步。

![Motor5](../assets/post-pics/Motor5.png)

步进电机的优势：成本低、扭矩大、可用于开环系统、控制简单（位置正比于输入脉冲数、速度正比于输入脉冲频率）、更安全（故障便停止工作）、寿命长（无电刷换向器等，只有轴承会磨损）、低速、重复定位精度高、误差不累积、过载安全（但会影响精度）、适合于恒负载场合、绕组通电且转子静止时提供满载扭矩（保持扭矩）、断电也提供扭矩（阻尼扭矩）、提供低速大扭矩、启停和反转响应好

步进电机的劣势：效率低（由于保持扭矩，无论负载如何都消耗功率）、扭矩随转速增加迅速下降，精度低于伺服电机、开环时要注意潜在的失步（如负载过大或移速过快可能丢步）、扭矩惯性比大故不能快速加速负载、中高速时噪声大、克服阻尼扭矩会降低运行时的实际扭矩

更复杂的机器人和机床一般使用带编码器和闭环控制器的伺服电机

- 伺服电机

由控制电路、电机、轴、电位器、传动齿轮、放大器和编码器构成，通过传感器实现位置反馈。伺服电机分类有三个依据：交直流、有刷无刷、同步异步。交直流的主要区别在于控制速度的能力，直流电机在负载不变情况下，转速与供电电压成正比；交流电机转速由施加电压的频率和磁极数决定；另外，交流电机能承受更大的电流，并且在需要高重复性和高精度的场景中更常见。有刷电机通过电刷和换向器换向，简单便宜；无刷电机则通过电子方式进行换向，一般通过霍尔传感器或编码器实现，效率高更可靠噪声小。直流电机通常按照有刷无刷进行分类，交流电机通常按照同步异步进行分类。

直流电机转速取决于施加的电压，通常是电位器产生电压作为放大器的输入。在一些电路中，使用控制脉冲来产生直流参考电压，参考电压与电机期望的位置和速度相对应，作用于脉宽电压转换器。反馈信号传感器往往是一个电位器，通过齿轮机构产生与电机轴绝对角度相对应的电压，输入到放大器，反馈电压与期望电压进行比较产生误差电压，作用到电机电枢上，使得电机旋转。

![Motor6](../assets/post-pics/Motor6.png)

交流伺服电机：同步交流伺服电机的定子由圆柱形框架和定子铁芯组成，电枢线圈绕在定子铁芯上；转子由永磁体组成，定子通电励磁时，转子与定子激励场，场与定子以相同速度旋转；定子不在通电时，由于没有转子电流，转子也会停转。可在转子上安装编码器获得转子与定子的相对位置。异步电机定子由定子铁芯、电枢绕组和导线组成，转子由转轴和转子铁芯组成。只有定子绕组由交流电源供电，产生旋转磁场，磁场和转子导体之间的相对速度在转子中产生感应电磁力，产生电磁转矩。

![Motor7](../assets/post-pics/Motor7.png)

---

## 通讯协议

单片机和不同外设以及其它单片机通信时，需要用到不同的通信方式，常见的有 UART、I2C、SPI、RS232、RS485 等

UART（Universal Asynchronous Receiver-Transmitter）是通用异步串行总线。物理层由相互独立的两根线实现，收发各一根，全双工通信（可同步收发），双方约定好通信速率（波特率），以数据包的形式传输数据。数据包由起始位、数据位和停止位构成。

UART 的缺点：不能远距离传输信号、通信速度慢、不能一对多通信。针对以上缺点分别衍生出了 RS232/RS485、SPI、I2C 通信方式。

RS232/RS485：由于串口通信使用 TTL 电平，故传输距离有限，一般用于同一块电路板或两块很近的电路板之间的两个芯片进行通信，否则信号容易受到干扰，远距离通信需要加入专门的芯片来抗干扰。RS232 最大通信距离可达 30m，RS485 最大通信距离可达 1000m；RS485 还支持一对多通信。

SPI：UART 的最高通信速率一般为 115200bps，由于 UART 通信需要约定波特率，而受限于 MCU 运行频率和时钟的准确性，波特率很难做到完全一致，传输速率过快容易误码。SPI 使用一个

I2C 解决单片机一对多通信的问题，通信线路少，节约 IO 资源降低 PCB 布线成本。

I2C 总线有时钟线和数据线，时钟线用于同步信号，发送端在时钟高电平时发出数据，接收端在时钟高电平接收数据。总线上配有上拉电阻，默认处于高电平状态，芯片内部打开 MOS 管就将总线信号拉低输出低电平（实际上就是 GPIO 开漏输出）。由于采用开漏输出和上拉电阻，I2C 信号的抗干扰能力较弱，一般用于同一块电路板上的芯片之间的通信。

多个设备需要同时发送数据时，由软件协议决定优先级。

---

## 嵌入式扫盲

嵌入式处理器：

MCU（单片机）是集成了处理器内核、内存、输入输出接口和时钟的单一芯片，常见的 MCU 有 89C51,STM32,ESP32；入门之选有 Arduino、树莓派（SoC 可运行 Linux 系统，芯片包含了 ARM 架构的处理器核心，ARM 公司设计了一系列低功率高性能的处理器架构）

DSP（数字信号处理）是专门用于处理数字信号（音频、图像等）的芯片：机器指令对卷积、傅里叶变换、乘除法等运算

FPGA（可编程逻辑门阵列）在实际使用前由用户编程的集成电路，利用可编程互联（verilog/VHDL）将可编程逻辑块按特定的顺序形成复杂的组合逻辑或时序逻辑

硬件包括处理器、存储器、传感器和执行器，软件包括应用程序、驱动程序、算法等，由数据+可执行代码+操作系统组成。连接软硬件的是固件，用于初始化硬件、加载操作系统或直接执行控制功能

典型的 MCU 结构与功能：处理器（CPU 运算控制寄存、时钟->定时器->中断->看门狗）、存储器（片上存储（ROM（程序启动、内核功能调用）、SRAM（运行临时数据）、Flash（程序代码、数据、固件）））、IO（外设接口、无线通信）

单片机与外部交互的方式：GPIO、PWM、ADC、DAC

芯片之间交互的方式：UART、SPI、I2C

单片机之间交互的方式：Wi-Fi，Zigbee，NB-IoT，Bluetooth，LoRa

---

## 嵌入式驱动开发规范

框架分为 App 和 Module 两层，App 为实现具体功能的应用逻辑，Module 为所有依赖的驱动，包括 Utilities，Device，Algorithm，希望全部以 lib 和头文件形式引入。

框架不再对 HAL 库提供的外设接口和数据结构作进一步的封装，而是在 HAL 库基础上编写各种外设的驱动

框架用 C 语言编写，头文件加入方式重复包含的宏定义

```c
#ifndef __XXX_H__
#define __XXX_H__

/*put your code here*/

#endif
```

框架中的数据结构用 typedef struct 或 typedef enum 进行封装

```c
typedef struct
{
	/*put your code here*/
} XXX_TypeDef;

typedef enum
{
	/*put your code here*/
} XXX_Enum;
```

头文件中的函数声明需添加注释，包括 description（描述函数功能），param 和 return（自动提取）

```c
/
 * @description:
 * @param {PWM_HandleTypeDef} *pwm
 * @return {*}
 */
```

文件注释包括 Author，LastEditTime，Description（描述文件功能）

```c
/*
 * @Author: Hatrix 3113624526@qq.com
 * @LastEditTime: 2024-12-11 15:26:35
 * @Description: PWM封装
 */
```

---

## 基础篇

### ST 单片机原理介绍

STM32，是意法半导体制造的，基于 Cortex-M 内核的 32 位可编程 MCU，采用独立的数据和地址总线访问数据和程序存储器的哈弗计算机结构，配合一些片上外设，可以实现用程序控制一系列实用的设备。

微处理器内部结构，描述了总线和单片机上各个外设之间的连接方式

全局地址空间，以 G4 系列为例

几个常用的地址映射

1. Flash 存储器映射：STM32F103 系列单片机的 Flash 存储器容量大小不同，但一般都是从 0x0800 0000 地址开始映射的。用户程序代码和常量数据通常存储在 Flash 存储器中。
2. SRAM 存储器映射：STM32F103 系列单片机的 SRAM 存储器容量也不同，但一般都是从 0x2000 0000 地址开始映射的。程序中使用的变量、堆栈和缓存等通常存储在 SRAM 存储器中。
3. 外设寄存器映射：STM32F103 系列单片机有许多外设，每个外设都有一些寄存器用于配置和控制，这些寄存器通常映射在 0x4000 0000 到 0x5FFF FFFF 的地址范围内。每个外设的寄存器地址和访问方式都有一定的规定，需要查阅相关的技术文档来了解。
4. System Memory 映射：STM32F103 系列单片机的 System Memory 是指内置的 Bootloader 程序存储区域，这个区域的地址范围是从 0x1FFF F000 到 0x1FFF F7FF，大小为 2KB
5. 位带映射：STM32F103 系列单片机的位带映射功能可以将某个单个位的读写操作映射到一个整个“字”的读写操作，这种映射方式可以提高对某些位操作的效率，但需要在编程时进行特殊的设置。

为了提高位操作的效率，一些单片机引入了位带映射技术。该技术通过将每个位（bit）与一个单独的内存地址进行映射，使得对该位的操作可以像对内存变量一样进行，从而可以大大简化位操作的流程。

### ST 芯片文档分类

- 参考手册：一般面向应用程序开发人员，详细完整。为用户使用单片机提供了完整的存储器和外设信息。
- 数据手册：介绍了芯片的主要外设资源和电特性参数。
- 编程手册：为单片机用户提供完整的编程指南。
- 用户手册：各种软件硬件的操作方法。
- 应用笔记：一些具体问题的解决方案。

一般来说，用得最多的是参考手册

### ST 芯片命名规则

### ST 芯片选型

1. 应用场景和需求：首先需要明确使用 STM32 的应用场景和需求，例如需要控制什么设备或执行什么任务，需要处理多少数据和信号，需要多大的处理能力和存储空间等。这些因素将直接决定 STM32 芯片的选型范围和性能要求。
2. 外设和接口：STM32 支持各种不同的外设和接口，例如通用输入输出（GPIO）、模拟转换器（ADC）、通用同步异步收发器（USART）、USB、以太网等。需要根据具体应用的需要选择适合的外设和接口，同时也需要考虑这些外设和接口的电气特性、数量、速率和支持程度等。
3. 处理器内核和架构：STM32 支持不同的 ARM Cortex 处理器内核和架构，包括 Cortex-M0、Cortex-M3、Cortex-M4、Cortex-M7 等。需要根据具体应用的需求选择适合的处理器内核和架构，例如需要更高的计算性能、更多的存储空间和更高的时钟速度等。
4. 电源管理和功耗：STM32 支持不同的电源管理和功耗优化技术，包括低功耗模式、睡眠模式、停机模式等。需要根据应用场景和电源供应条件选择适合的电源管理和功耗优化方案，以达到更长的电池寿命和更低的功耗。
5. 可用的开发工具和平台支持：选型 STM32 还需要考虑可用的开发工具和平台支持，例如开发板、软件开发工具、在线论坛、文档等。需要选择适合自己的开发工具和平台，以便更快速、更准确地进行开发和测试。

## HAL 库

https://www.eet-china.com/mp/a330816.html

STM32 有三种开发方式：直接配置寄存器、标准库和 HAL 库；对于 STM32 而言，寄存器的数量庞大，直接配置寄存器需要经常性的翻阅数据手册，不建议使用；而对于后面两种库的封装，目前 HAL 库更为普遍，原因在于 ST 公司已经停止更新标准库，转而主推 HAL 库。此外，随着 STM32CubeMX 和 STM32CubeIDE 等工具的支持，HAL 库提供了更加便捷的开发体验，允许开发者通过图形化界面配置外设并生成初始化代码。尽管 HAL 库可能会带来更大的代码体积和稍慢的运行速度，但其易用性和官方支持使得它成为许多开发者的首选。

HAL 库几大特点

1. 句柄 Handle

句柄中包含了一个外设在整个项目流程中都要设置的各个成员变量，使用时调用初始化时定义的句柄就好。

1. MSP 函数

MCU Specific Package，是指和 MCU 相关的初始化，可以配合句柄达到很强的移植性。

1. Callback 函数

类似于 MSP 函数，主要帮助用户应用层的代码编写。以中断为例，HAL 库中断服务程序接管对中断的判断、读出数据到缓冲区，清除中断标志位等等，用户在 Callback 回调函数中编写处理逻辑即可。

HAL 库结构：

stm32f4xx.h：同系列芯片的不同具体型号的定义，是否使用 HAL 库等的定义，并根据定义的芯片型号包含具体的芯片型号的头文件

hal.h：HAL 库通用部分，初始化，获取时刻，延时等

hal_def.h：HAL_StatusTypeDef， HAL_LockTypeDef 等 HAL 库通用宏定义

hal_cortex.h：Cortex 内核常量，如中断优先级定义

hal_conf.h：hal 驱动程序配置，启用 MCU 上哪些外设，对 RCC 时钟频率设置，用户级别的配置文件，实现对 hal 库的裁剪

stm32f4xx_hal_ppp.c/.h：库文件，主要的外设或者模块的驱动源文件，包含了该外设的通用 API；stm32f4xx_hal_ppp_ex.c/.h：外围设备或模块驱动程序的扩展文件。这组文件中包含特定型号或者系列的芯片的特殊 API。以及如果该特定的芯片内部有不同的实现方式，则该文件中的特殊 API 将覆盖\_ppp 中的通用 API。

hal_msp.c：MCU Specific package 特定程序包，只有.c 没有.h。包含用户应用程序中使用的外设的 MSP 初始化和反初始化

system_stm32f4xx.c：系统初始化，系统核心时钟更新；包含 SystemInit()函数，该函数在刚复位及跳到 main 之前的启动过程中被调用

startup_stm32f4xx.s：芯片启动文件，主要包含堆栈定义，终端向量表等；MCU 复位后首先要执行的程序，初始化 SP 和 PC，中断向量表，执行 SystemInit，执行 main

it.h：中断函数原型，中断服务例程 ISR

main.c：调用 HAL 库初始化，配置系统时钟，外设初始化；main 函数：HAL 库初始化，系统时钟配置，外设初始化，while（1）

main.h：引脚别名

HAL 库提供 API 可以分为三类

1. 初始化/反初始化：HAL_PPP_Init(), HAL_PPP_DeInit()
2. IO 操作：HAL_PPP_Read(),HAL_PPP_Write(),HAL_PPP_Transmit(), HAL_PPP_Receive()
3. 控制：HAL_PPP_Set(),HAL_PPP_Get()
4. 状态和错误：HAL_PPP_GetState (), HAL_PPP_GetError ()

在此结构下，用户代码的处理主要分为：处理句柄外设（实现用户功能）、处理 MSP、处理各种回调函数三部分

1. 外设句柄定义

每个外设抽象成了一个称为 ppp_HandleTypeDef 的结构体，其中 ppp 就是每个外设的名字。所有的函数都是工作在 ppp_HandleTypeDef 指针之下。外设句柄支持多实例，即每个外设/模块实例都有自己的句柄。因此，实例资源是独立的下面，以 ADC 为例，外围进程相互通信：该句柄用于管理进程例程之间的共享数据资源。

```
typedef struct
{
  ADC_TypeDef                   *Instance;              /*!< Register base address */
  ADC_InitTypeDef               Init;                   /*!< ADC initialization parameters and regular conversions setting */
  DMA_HandleTypeDef             *DMA_Handle;            /*!< Pointer DMA Handler */
  HAL_LockTypeDef               Lock;                   /*!< ADC locking object */
  __IO uint32_t                 State;                  /*!< ADC communication state (bitmap of ADC states) */
  __IO uint32_t                 ErrorCode;              /*!< ADC Error code */
  ADC_InjectionConfigTypeDef    InjectionConfig ;       /*!< ADC injected channel configuration build-up structure */
} ADC_HandleTypeDef;
```

当然，对于那些共享型外设或者说系统外设来说，他们不需要进行以上这样的抽象，这些部分与原来的标准外设库函数基本一样。如：GPIO，SYSTICK，NVIC，RCC，FLASH

1. 三种编程模式

HAL 库对所有的函数模型也进行了统一。在 HAL 库中，支持三种编程模式：轮询模式、中断模式、DMA 模式（如果外设支持）。其分别对应三种类型的函数，如

```
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc);
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length);
HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc);
```

此外，新的 HAL 库架构下统一采用宏的形式对各种中断等进行配置，针对每种外设主要有以下宏：

```
__HAL_PPP_ENABLE_IT(HANDLE, INTERRUPT)：使能一个指定的外设中断
__HAL_PPP_DISABLE_IT(HANDLE, INTERRUPT)：失能一个指定的外设中断
__HAL_PPP_GET_IT (HANDLE, __ INTERRUPT __)：获得一个指定的外设中断状态
__HAL_PPP_CLEAR_IT (HANDLE, __ INTERRUPT __)：清除一个指定的外设的中断状态
__HAL_PPP_GET_FLAG (HANDLE, FLAG)：获取一个指定的外设的标志状态
__HAL_PPP_CLEAR_FLAG (HANDLE, FLAG)：清除一个指定的外设的标志状态
__HAL_PPP_ENABLE(HANDLE) ：使能外设
__HAL_PPP_DISABLE(HANDLE) ：失能外设
__HAL_PPP_XXXX (HANDLE, PARAM) ：指定外设的宏定义
__HAL_PPP_GET_IT_SOURCE (HANDLE, __ INTERRUPT __)：检查中断源
```

1. 三大回调函数

在 HAL 库的源码中，到处可见一些以\_\_weak 开头的函数，而且这些函数，有些已经被实现了，有的则没有被实现。

通常来说，HAL 库负责整个处理和 MCU 外设的处理逻辑，并将必要部分以回调函数的形式给出到用户，用户只需要在对应的回调函数中做修改即可。HAL 库包含如下三种用户级别回调函数（PPP 为外设名）：

1. 外设系统级初始化/解除初始化回调函数（用户代码的第二大部分，即对于 MSP 的处理），在 HAL_PPP_Init() 函数中被调用，用来初始化底层相关的设备（GPIOs, clock, DMA, interrupt），如：

2. 1.

   外设系统级初始化/解除初始化回调函数（用户代码的第二大部分，即对于 MSP 的处理），在 HAL_PPP_Init() 函数中被调用，用来初始化底层相关的设备（GPIOs, clock, DMA, interrupt），如：

```
__weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
```

1. 处理完成回调函数：HAL_PPP_ProcessCpltCallback（Process 指具体某种处理，如 UART 的 Tx），如：

2. 1.

   处理完成回调函数：HAL_PPP_ProcessCpltCallback（Process 指具体某种处理，如 UART 的 Tx），如：

```
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
```

当外设或者 DMA 工作完成后时，触发中断，该回调函数会在外设中断处理函数或者 DMA 的中断处理函数中被调用错误处理回调函数

- 3、当外设或者 DMA 出现错误时，触发中断，该回调函数会在外设中断处理函数或者 DMA 的中断处理函数中被调用错误处理回调函数，如：

```
__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef hspi)*
```

HAL 库结构中，在每次初始化前（尤其是在多次调用初始化前），先调用对应的反初始化（DeInit）函数是非常有必要的。某些外设多次初始化时不调用返回会导致初始化失败。

（用户代码的第三大部分：对于上面第二点和第三点的各种回调函数的处理）在实际使用中，发现 HAL 仍有不少问题，例如在使用 USB 时，其库配置存在问题。

## 时钟源和时钟树

为什么需要时钟信号

1. 门电路运行有延迟，导致运行中的混乱状态，一种解决思路是加上边沿触发器，用时钟信号统一控制 ，使得门电路稳定之后再触发
2. 许多外设需要精确的时钟脉冲信号，比如串口的波特率、定时器计时、IIC 和 SPI 的时钟线、ADC 的采样间隔

晶振提供相对准确的时钟信号，RCC_OSC_IN 和 RCC_OSC_OUT 是外部晶振输入输出，OSC 是 oscillator（振荡器）的缩写

AHPB（Advanced High Performance Bus）被称为先进高性能总线的总线结构，处理器，内存，DMA 以及各种外设都连接在这一总线上，HCLK 是这一总线中的时钟线；处理器、内存和 DMA 直连 HCLK

处理器内核中有一个称为 SysTick（系统滴答）的定时器，通过分频器与 HCLK 连接（To Cortex System Timer）

外设时钟分门别类地连接在两个 APB（Advanced Peripheral Bus）总线上，APB 总线通过一种桥接器连接到 AHB 总线上，HCLK 经过分频器连接到 APB 上，分频后的时钟信号称为 PCLK1，PCLK2；定时器外设前，还有一个倍频器，ADC 还有一个专属的预分频器（ADC 需要采集一段时间才能更准确地获取电压值，因此时钟频率需要慢下来）

HCLK 地来源有二：HSI 和 HSE，HSI 是默认使用的时钟源，无需外部电路，精度较差；HSE 需要从外部接入晶振，脉冲精度较高，选择其一接入时钟数，接入的信号称为 SYSCLK，再经过分频器接入 HCLK

系统时钟还有一个选项，也就是 PLLCLK 锁相环时钟，起倍频器的作用，其输入可以是 HSI 或 HSE

FCLK 自由运行时钟（free running），低功耗模式的停止模式时，HCLK 停止传输时钟脉冲，FCLK 会继续运行，为唤醒的中断采样提供时钟信号

CSS 时钟安全系统，在 HSE 发生故障时，立即将时钟源切换回 HSI 并产生中断

LSE 和 LSI 供给 RTC 时钟和看门狗

MCO 时钟输出功能

SYSCLK 直接作为 Ethernet 精确时钟协议 PTP 的时钟信号

LSE 固定为 32.768KHz，可以通过一个 15 位的二进制计数器精确分频为 1Hz；LSI 为 32KHz

### 外设介绍

### 通用输入输出端口 GPIO

STM32 的 GPIO（通用输入/输出）引脚设计用于执行一系列的输入和输出操作。GPIO 是微控制器与外部设备交互的主要方式之一，可以用于多种不同的应用。

STM32 有多个 GPIO（通用输入输出引脚）端口，每个端口有 16 个引脚和 4 个 32 位寄存器，GPIO 内部的电路结构大致如下：

输出有两个控制指令的来源，一个是用 WritePin 控制的输出寄存器，另一个是串口等的片上外设，根据控制来源的不同，分为普通输出和复用输出

GPIO 有八种模式，分别是： 输入浮空，输入上拉，输入下拉，模拟，上拉或下拉的开漏输出（用于共用总线的信号），上拉或下拉的推挽输出（为增强驱动能力可以上拉），上拉或下拉的复用功能推挽，上拉或下拉的复用功能开漏

推荐阅读：

[GPIO(简介、IO 端口基本结构、GPIO 的八种模式、GPIO 寄存器、通用外设驱动模型、GPIO 配置步骤、编程实战)-CSDN 博客](https://blog.csdn.net/wdxabc1/article/details/139192494)

[单片机的上拉电阻 到底在拉什么？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1Kb411o7ai/?spm_id_from=333.788)

[推挽 开漏 高阻 这都是谁想出来的词？？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1D84y1c7GV/?spm_id_from=333.788&vd_source=1d0891b41fe4e23dbf197eaf61dfa468)

### 定时器

STM32 的定时器分为高级控制定时器，通用定时器，基础定时器三类。基础定时器只能用于定时，另外两种还具有输入捕获 Input Compare、输出比较 Output Compare、PWM 输出等功能。

### 中断与 DMA

### 串口通讯

### Debug 外设工作原理

DBG 支持模块（红框标注部分，也可以看作一个外设）通过一条专用的 AHB-AP 总线和调试接口相连（Jtag 或 swd），并且有与数据和外设总线直接相连的桥接器。它还同时连接了中断嵌套管理器（因此同样可以捕获中断并进行 debug）和 ITM、DWT、FPB 这些调试支持模块。因此 DBG 可以直接获取内存或片上外设内的数据而不需要占用 CPU 的资源，并将这些数据通过专用外设总线发送给调试器，进而在上位机中读取。

FPB 是 flash patch breakpoint 闪存指令断点的缩写，用于提供代码断点插入的支持，当 CPU 的指令寄存器读取到某一条指令时，FPB 会监测到它的动作，并通知 TPIU 暂停 CPU 进行现场保护。

DWT 是 data watch trace 数据观察与追踪单元的缩写，用于比较 debug 变量的大小，并追踪变量值的变化。当你设定了比较断点规则（当某个数据大于/小于某个值时暂停程序）或将变量加入 watch 进行查看，DWT 就会开始工作。DWT 还提供了一个额外的计时器，即所有可见的 TIM 资源之外的另一个硬件计时器（因为调试其他硬件定时器的计时由于时钟变化可能定时不准，而 DWT 定时器是始终正常运行的）。它用于给自身和其他调试器模块产生的信息打上时间戳。我们的 bsp 中也封装了 dwt 计时器，你可以使用它来计时。

ITM 是 instrument trace macrocell 指令追踪宏单元的缩写，它用于提供非阻塞式的日志发送支持（相当于大家常用的串口调试），SEGGER RTT 就可以利用这个模块，向上位机发送日志和信息。这个硬件还可以追踪 CPU 执行的所有指令，这也被称作 trace（跟踪），并将执行过的指令全部通过调试器发送给上位机。当 debug 无法定位 bug 所在的时候，逐条查看 cpu 执行的指令是一个绝佳的办法，特别是你有大量的中断或开启了实时系统时。

以上三个模块都需要通过 TPIU（trace port interface unit）和外部调试器（j-link 等）进行连接，TPIU 会将三个模块发来的数据进行封装并通过 DWT 记录时间，发送给上位机。

### GDB 调试 MCU 原理

不论使用 MDK（KEIL）还是 VSCode 还是 Ozone，实际上背后的流程相同。首先 GDB 会建立 TCP/IP 端口并提供接口，调试服务器（Server）作为硬件调试器和 GDB 软件的桥梁，将硬件调试器的相关功能（也就是 DBG 外设支持的那些功能）映射到 GDB 的接口上（通过连接到 GDB 建立的端口）。之后启动调试，将可执行文件下载到目标 MCU 上，然后从 main 开始执行

当然你也可以选择从其他启动点开始执行，调试器开始执行的位置叫做 entry point。同样，在 MCU 已经正在运行程序的时候，可以 attach 到程序上开始监控（attach=附加，贴上；很形象了）。

而对于直接运行在电脑上的程序（.exe），就不需要 GDBserver 和物理调试器，GDB 程序可以直接访问电脑上运行的程序和 CPU 的寄存器等。
