---
title: 深度学习python基础
description: 开发环境、基本语法和常用库
author: Hatrix
date: 2025-07-08 16:55:00 +0800
categories: [知识储备]
tags: [机器学习]
math: true
mermaid: true
pin: false
image:
  path: https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250708170226830.png
  alt: 深度学习基础
---

## 环境配置前置知识

安装的 python，主要包含了 Lib 库（包含标准库和 site-packages 第三方包存储位置）、Scripts（包含 pip.exe 包管理器）以及 python.exe 解释器；安装的时候还安装了 python 启动器（用于管理多个不同版本的 python）

虚拟环境即将上面的东西复制一份（但一般情况下不含标准库，标准库通过符号链接或直接引用系统 python 安装路径下的标准库；另外，conda 出于环境隔离的考虑，会将标准库一并复制。以及会将解释器和包管理器统一放在 Scripts 路径下，主要是为了方便添加环境变量）；虚拟环境本质上是对解释器、包管理器的一种隔离式复制。

必须使用不同的策略来允许【py】脚本使用基于脚本指定的 Python 解释器版本来选择合适的 Python 解释器。我们也希望在 Windows 中和 Unix 中同样运行【Shebang】的能力，并且——没有什么是又好使又不需要发明新的语法或者约定来描述更让人愉快的事情了！经过后来的完善，在 PEP 397 中正式出现并伴随 Python3.3 版本发布。它叫【Python Launcher】。Python launcher 是用于 Windows 中的一个实用程序，可帮助我们定位和执行不同版本的 Python 解释器。它允许脚本或者命令行指示特定的 Python 版本的首选项，并将定位并执行该版本。说人话就是它很智能的区分开是你想要手动指定解释版本执行 py 脚本，还是想使用脚本文件指定的解释器。你手动的选择 Python 解释器，这是调用了你在【PATH】中的 Python 变量。Python launcher 根据文件头自动帮我们调用了指定版本的解释器来执行该文件。python launcher 是适用于 windows 的 python 启动器，可帮助我们定位和执行不同的 python 版本。它允许脚本（或命令行）为特定的 python 版本指示首选项，定位并执行该版本。

在 Linux 中(基于 Unix 的系统中)，通过软连接的方式来绑定指定的 Python 解释器。在 Unix/Linux 系统中，Shebang（也称为 Hashbang） 是一个特殊的符号序列，位于脚本文件的第一行，用于指定执行该脚本的解释器。它的格式为：`#!/path/to/interpreter`，其中`#!`是 Shebang 符号，后面跟着解释器的路径。Windows 系统不支持 Shebang：Windows 通过文件扩展名（如`.py`）和关联程序来确定解释器。

虚拟环境的激活和去激活就是在环境变量 Path 中添加或去除虚拟环境的解释器路径，相当于对安装位置默认的路径进行截胡。在虚拟环境下安装第三方库，就会安装到虚拟环境的路径下了

pip freeze 可以将环境下的包以 requirements.txt 的格式导出，使用 pip install -r requirements.txt 既可得到一个一样的环境

环境变量 Path：应用程序的搜索路径

anaconda 创建的虚拟环境存放在安装路径下的 envs 目录下，vscode 中 ctrl+shift+p，python:select interpreter 即可导入虚拟环境

当你运行 Python 脚本时，解释器会将 `.py` 源代码文件编译成一种中间形式 —— **字节码（bytecode）**，这种形式的文件扩展名为 `.pyc`，Python 会把这些文件缓存到 `__pycache__` 文件夹中。

python解释器有CPython和JPython，分别是用C语言和Java写的，一般安装的是CPython

安装时勾选“Precompile standard library”这个选项，前者会帮助我们自动配置好环境变量，后者会预编译标准库（生成`.pyc`文件），这样在使用时就无需临时编译了

安装anaconda后，终端或命令提示符会被 Anaconda 篡改（每次启动自动激活虚拟环境）

PyCharm 只是一个辅助写 Python 代码的工具，它本身并不具备运行 Python 代码的能力，运行 Python 代码靠的是我们上面安装的 Python 解释器。

dataset和Dataset，前者是module，后者是class

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250714201016863.png)

## 命令行工具CLI

CMD 不执行 PowerShell hook 脚本 `conda-hook.ps1`，它的激活逻辑是通过 `conda.bat` 文件完成的，不依赖这个 PS 脚本。

这说明你运行的是 **打包版本的 Conda**（比如 `_conda.exe`），而不是正常安装在 `D:\Develop\Anaconda\Scripts\conda.exe` 的 Conda。

可能原因包括：

- 你安装过 **Anaconda Navigator** 之类的 GUI 工具，这些工具内部集成了打包的 `_conda.exe`。
- 系统 PATH 优先级不对，`_conda.exe` 被抢在前面。
- PyCharm 在 Terminal 设置中调用的不是你手动设置的 `conda.exe`，而是其它工具劫持的版本。

```shell
$ D:\Develop\Anaconda\_conda.exe shell.powershell hook
```

这是 Conda 的终端初始化命令，意思是给当前 PowerShell 终端配置 Conda 所需要的启动脚本（hook），你需要 `Invoke-Expression` 执行它，让终端具备使用 `conda` 命令的功能。



`conda-hook.ps1` 是 Conda 为 PowerShell 定制的 **自动命令补全和函数定义脚本**。比如：

- 定义 `conda` 命令
- 实现 `conda activate` 时自动修改 `PATH`
- 改变 prompt 显示 `(env)` 名字
- 切换 `PYTHONPATH`、`PATH`、环境变量等



在 PyCharm 中打开 PowerShell 并尝试使用 Conda 时发生了什么？PyCharm 启动 PowerShell 终端时，如果你配置了解释器为 Conda 环境，它会尝试自动帮你“激活环境”。

1. 调用 powershell.exe

2. 执行 conda shell.powershell hook
3. 通过 hook 输出的脚本定义 activate 命令
4. 自动执行 conda activate your-env
5. 显示 (your-env) 前缀



Anaconda Prompt 本质上是一个 CMD 命令行 + 初始化脚本。它启动时，执行了类似：

```shell
C:\Users\HRX\Anaconda3\Scripts\activate.bat
```

然后设置好 `PATH` 等环境变量，并激活 `(base)` 环境。所以你在其中运行 Conda 命令或 Python 都是准备好的，不会出错。 Anaconda Prompt 调用的是标准的 `.bat` 脚本路径，不依赖 `shell.powershell hook`，也就没有 `conda-hook.ps1` 不存在的问题。



不同 shell 使用不同 hook 脚本：

- `bash` 用 `conda.sh`
- `cmd` 用 `activate.bat`
- `powershell` 用 `conda-hook.ps1`



解释器配置是 **运行 Python 程序时的环境定义**，而 PyCharm 的终端也会尝试匹配解释器设置，默认行为是：在终端中打开时自动激活解释器对应的环境。

`base` 是 Anaconda 安装后默认创建的虚拟环境，为了让用户 **开箱即用**，默认在终端启动时就激活 base 环境。如果设置了：

```shell
auto_activate_base: false
```

那么终端就不会自动激活 `(base)`，必须手动激活base环境；不激活的活就在系统默认环境下，此时

- `python` 和 `pip` 是来自系统环境或 PATH 中优先项
- 不一定能用 `conda`（如果没加 PATH）
- 没有任何虚拟环境被激活

此时你在操作系统本地的环境（也叫 "系统 Python" 或 "裸机环境"）中。这种环境容易造成 **依赖污染、库版本冲突、难以迁移项目**，这正是虚拟环境存在的原因。



终端（Terminal）是人机交互的窗口，是一个 UI 界面（PyCharm/VSCode/系统终端），背后调用的是 CLI。CLI是Command-Line Interface 的简称，泛指通过输入命令和计算机交互的模式。CMD（命令提示符）是Windows 的传统命令行程序，运行 `.bat` 文件、支持基础命令。PowerShell是更强大的 CLI 工具，支持对象管道、脚本系统，是 CMD 的“升级版”。Anaconda Prompt实际上就是一个 CMD，但在打开时自动执行 `activate.bat`，激活了 `(base)` 环境。Bash是GNU Shell，Linux/WSL/Mac 默认终端；zsh是Z Shell，bash 超集，macOS 默认，Linux 可装，有高亮、补全等功能；

```objective-c
PyCharm Terminal
    └─ PowerShell / CMD / bash / zsh  ←← 你可自由设置用哪个终端

Windows Terminal / 系统终端
    └─ CMD / PowerShell（或你安装的 git-bash、WSL 等）

Anaconda Prompt（是 CMD + auto activate base）
```

cmd、powershell、anaconda prompt、vscode终端，它们的底层本质都是命令行终端（shell），只是默认的 Shell 类型、初始化方式和集成度不同。conda虚拟环境只要完成手动初始化，在任何终端都可以使用。

`conda activate` 并不是系统命令，而是一个 shell 函数/脚本。实际效果如下

1. **修改 PATH 环境变量**
     把虚拟环境的 `Scripts/`、`Library/bin/` 加入 PATH
2. **设置一些环境变量**
     比如 `CONDA_DEFAULT_ENV`, `CONDA_PREFIX`
3. **切换 Python 可执行路径**
     让你运行的 `python` 实际指向虚拟环境中的那个



所谓“打包版本工具”，通常是指使用如 [PyInstaller](https://pyinstaller.org/) / cx_Freeze / Nuitka 等工具，将 Python 脚本打包成一个 **单独可执行文件（.exe）** 的程序。特征包括：

- 不需要依赖本地 Python 安装
- 所有脚本、依赖、资源被封装在一个 `.exe` 文件中
- 启动时会临时解压到类似 `C:\Users\HRX\AppData\Local\Temp\_MEIxxxxxx` 的路径执行
- 会在内存或临时目录中模拟一个 Python 环境

Anaconda 官方为了方便非技术用户，**将 Navigator（GUI 管理器）打包成了独立可执行文件**，就像一个“傻瓜式应用”。



```shell
conda install -c anaconda pkg_name
```

-c表示channel，`anaconda` 是 Conda 的**官方主渠道名**，对应 Anaconda 公司维护的软件仓库。



- **目录**是文件系统中实际存在的容器，用于组织文件。
- **路径**是用于定位文件或目录的字符串，描述了访问它们的路线。

**所有目录都是路径，但并非所有路径是目录**，路径也可以指向文件。



np_array的图片是HWC（height，width，channel），用shape属性可以查看

函数传参时如果按照顺序，是不用写参数名称的，反之则需要显式写出参数名

tensorboard命令

```shell
tensorboard --logdir=my_log_path --port=6007
```

tensorboard可以画出训练损失图，可以查看数据集中的图片

transform：对图片进行变换



## Python语法补充

“>”为大端序列，"<"为小端序列

## Pytorch使用

```bash
conda create -n my_env_name python=3.10
conda activate my_env_name
conda deactivate
conda env list
```

加载数据：pytorch中的数据主要是两个类型，一个是dataset，一个是dataloader。dataset提供一种获取数据及其labl并进行编号的方式，dataloader用于打包数据成batch并为后面的网络提供不同的数据形式。

dataset实现的功能包括如何获取每一个数据及其label、提供数据总数。根据数据集的组织形式实现自己的dataset，包括——init——，——getitem——，——len——三个方法



self相当于类当中的一个全局变量，类的使用，——getitem——

类里面，——init——首先把参数全读进来，以后——init——都用self.xxx而不用传入的参数
