> 为了节约电控大量整定PID参数的时间，以及方便以后使用依赖于模型的控制器，需要对机器人进行建模。本文以步兵yaw轴云台为例给出一个demo，分步骤讲解如何在机器人上使用系统辨识以及自动参数整定
>
> 参考数据集、matlab源码以及simulink文件在文末给出

本系统辨识方案受官方系统辨识教程启发：[官方开源教程-系统辨识基础教程](https://bbs.robomaster.com/article/3559)

## 方案简述

希望辨识出以电机电流为输出，电机角速度为输出的开环传递函数模型，以便在simulink中使用。需要采集电机带负载在正常工况下的频率响应和阶跃响应，且为了消除随机误差，建议在不同时间，将机器人以不同方位放置在车架上进行测试。

经过尝试，如果辨识角度的传递函数，电机由于惯性，在不施加任何控制算法时，难以保证电机同一零点附近摆动，采集数据后需要进行复杂的数据处理工作，且效果不佳；故测试以角速度为输出的传递函数，由于仿真环境中是理想模型，对其积分即可得到角度。

## 数据采集和清洗

把车放在架子上，架子用桌子夹住，测试时按住底盘，尽量减小底盘的晃动

![image-20250526223022352](../assets/post-pics/image-20250526223022352.png)

**采集频率响应和阶跃响应**

考虑到云台的转动惯量和实际工况，频率响应采集的频率范围为1~10Hz，中间每0.5Hz一档，电流幅值为6000

阶跃响应的电流范围为0~15000（正负交替）

系统辨识所涉及的代码如下

```
#define RESPONSE_MODE FREQ_RESPONSE

float openloop_spd_ref = 0.0f;
float openloop_spd_fdb = 0.0f;
int openloop_spd_amplitude = 6000.0f;

// 阶跃信号发生器
static void Process_Step(float coef)
{
        int tick = 0;
        while (tick < 1000)
        {
                openloop_spd_ref = coef * 1000;
                tick++;
                osDelay(1);
        }
}

// 频率信号发生器
static void Process_Freq(float freq)
{
        int tick = 0;
        float t_ms = round(1000. / freq);
        freq = 1000. / t_ms;
        while (tick < (20 * t_ms))
        {
                openloop_spd_ref = openloop_spd_amplitude * sin( freq * 2 * 3.1415926f * tick * 0.001f);
                tick++;
                osDelay(1);
        }
}

void Test_Response(void)
{
        GimbalYaw_ControlTypeDef *gimbalyaw = GimbalYaw_GetControlPtr();
        #if RESPONSE_MODE == FREQ_RESPONSE
        for (float freq = 1.0f; freq <= 10.0f; freq += 0.5f)
        {
                Process_Freq(freq);
        }
        #endif

        #if RESPONSE_MODE == STEP_RESPONSE
        for (int stepcoef = 1; stepcoef <= 15; stepcoef++)
        {
                Process_Step(stepcoef);
                stepcoef *= -1;
                Process_Step(stepcoef);
        }
        #endif
}
```

在除云台控制之外的另一个任务中调用Test_Response()函数，**openloop_spd_ref**（发给电机的电流）和**openloop_spd_fdb**（IMU角速度反馈）为需要采集的数据，

在不同时间段，机器人在架子上不同方位，频率响应和阶跃响应各测四次数据

**数据清洗**

去除掉频率响应数据中，程序刚运行电机还未启动时的数据

导入matlab，数据如下：

![image-20250526223037696](../assets/post-pics/image-20250526223037696.png)

## 模型辨识与验证

**模型结构选择与参数辨识**

以频率响应作训练集，阶跃响应作验证集

进行线性系统辨识，暂未加入非线性环节

选择传递函数作为系统结构

辨识出的结果如下

![image-20250526223112226](../assets/post-pics/image-20250526223112226.png)

选择符合物理规律的电机传递函数$\frac{K}{Ts + 1}$的形式，效果是最好的，置信度在百分之80多，如果增加零极点个数，置信度一般在百分之90多，但是在验证集上表现会比较差，即出现明显的过拟合

对于系统辨识工具箱中的其它选项，包括拟合算法，频率范围筛选，去除平均值作归一化等预处理和辨识方式，可以根据需要查阅和使用，部分选项笔者也不知道其作用，欢迎高手评论补充。

**模型验证**

阶跃响应作为验证集，效果如下

![image-20250526223125782](../assets/post-pics/image-20250526223125782.png)

可以发现，就验证效果而言，相对较好的G2和G4在幅值变大时效果很好；但所有模型在阶跃响应幅值不大时表现相对交叉，目前怀疑是机器人存在局部非线性环节（如云台松动、静摩擦力等），在此理想模型的构建中暂时不予考虑

## 模型仿真与控制器设计

取效果最好的G2系统作为云台电机在实际工况下的传递函数，在simulink中搭建最简单的速度-角度串级PID，同时加上输出限幅和积分限幅。

![image-20250526223132965](../assets/post-pics/image-20250526223132965.png)

使用PID_Tuner根据想要的控制效果自动整定，先整定速度环，再整定角度环。

此处仅搭建了最基础的串级PID，旨在启发读者用建模的方式设计控制器并进行参数整定的思路。后续可以加入前馈或其它优化控制效果的环节或算法。

## 从仿真到实车

将仿真中得到的参数放进代码中运行，得到结果如图，实际结果较好地符合了仿真结果

![sim2real666](../assets/post-pics/sim2real666.png)

此处有几点需要注意

1. 注意Matlab对离散PID和滤波器的实现，和代码中是否一致。

如步兵老框架中的I就和离散PID算法中的I不一致，步兵调参中所谓的I其实是$I * dt$（采样时间）

1. 注意检查单位，角度、弧度还是编码器的刻度，建议统一为弧度的标准单位。

如步兵老框架中，对IMU数据而言，角速度是弧度每秒，角度是度每秒

1. 就目前（2024.6.21）的效果而言，不敢说实际响应绝对精确地符合仿真，会有那么一点差别。simulink的PID模块内部其实很复杂，以积分抗饱和为例，有back-calulation和clamping两种实现，笔者尚不清楚它们的实现原理是否跟自己代码中的一致，也有可能导致实际和仿真的误差。

    但基于辨识整定出的参数一定是能用的，如果发现两者响应大相径庭，建议检查其它问题，如前两条中说的算法实现和单位，以及建模过程的数据采集，模型辨识等。

2. 针对第三点中提到的”实际响应不敢说绝对符合仿真“这一点，一方面是仔细分析，尝试加入非线性环节进行辨识，让模型更逼近实际工况，另一方面，就打比赛而言，笔者更建议是用相对准确的模型自动整定参数，放到机器人上跑，根据实际效果再花个几分钟手动微调达到想要的效果（比如第三点中提到的积分限幅）。