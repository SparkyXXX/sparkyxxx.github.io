线程同步：

多线程执行时，由于线程资源竞争导致的数据不一致问题，称为竞态条件。针对这一问题，需要对线程进行同步，即让原先异步的操作依次有序地进行。实现这一功能的方式有很多，其中最简单的一种是锁。同一时间只有一个线程可以获得锁的拥有权，其它线程必须等待这个锁被持有者释放，锁的获取和释放也称为上锁和解锁。锁的实现方式也有多种，具体来说也有互斥锁、自旋锁、读写锁、乐观锁、悲观锁等等。访问共享资源前上锁，访问结束后解锁，就可以保证线程同步。

然而频繁加锁解锁的操作是非常低效的，会完全打破线程的并发执行，可以根据具体情况，用其它附加操作消除线程不同步带来的影响。多个锁得嵌套使用可能造成线程死锁，一种解决方式是统一上锁顺序，另一种方式是干脆就使用单个锁。这样会损失一部分线程的并发性，但好处在于程序的逻辑会更清晰更容易维护。

建立在锁之上，线程中还有其它更复杂更高级的同步机制，如信号量、条件变量等，虽然也可用于保护共享资源，但它们更多地是用于在线程中传递信号，比如可以让线程进入等待，直到某个条件成立后再继续执行。信号量更加灵活，可以让所有线程进行等待，只让特定数量的线程被唤醒。

锁（Lock）是一种用来防止多个线程同时访问共享资源（比如一个内存地址），从而避免数据竞争的机制。

在计算机系统中，原语（primitive）是指操作系统或编程语言提供的最基本的、不可再分的操作。在并发编程中，“原语”通常指的是：不可中断、不可拆解的最小操作单元。同步原语是用来协调多个线程/进程对共享资源的访问，以避免数据竞争和错误状态的基本工具。

自旋锁是一种轻量的锁实现方式，线程会在循环中不断尝试获得锁，而不是让出调度权（比如不调用 `sleep` 或 `yield`）。自旋的意思是线程在等待锁的过程中，会“转圈圈”地反复尝试。

`__threadfence()` 是一个内存屏障指令，用于确保当前线程对全局内存或共享内存的写入操作在其他线程可见之前完成。

对于操作系统来说，一个任务就是一个进程（Process）。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。

需要一种方式，让计算机自动运作，于是诞生了操作系统。操作系统也是程序，但它拥有操作硬件的特殊权限，可以运行和管理其他程序。第一个操作系统加强了程序加载方式，当计算机运行完一个程序，会自动运行下一个程序，这叫批处理。随着计算机越来越普遍，各个计算机配置也不尽相同。为了方便管理外部设备并和它们交互，隐藏外部设备底层的硬件细节，发明了操作系统用以充当软件和硬件之间的媒介。更具体地说，操作系统提供 API 来抽象硬件，称为设备驱动程序。程序员可以用标准化机制和输入输出硬件交互。50 年代后期，世界上第一台超级计算机 Atlas 采用的 Atlas Supervisor 不仅能自动加载程序，还可以通过调度在单个 CPU 上运行多个程序。操作系统的这种能力叫多任务处理。每个程序都会占一些内存，在不同程序之间切换时为了不丢失数据，需要给每个程序分配专属内存块；这样做的另一个好处是，如果一个程序出错，它只能写坏自己所在的内存块，这叫内存保护。如果一个程序请求更多内存，操作系统会决定是否同意，但这样带来的问题是，一个程序分到的内存块可能并不是连续的。为了又发明了虚拟内存技术，来隐藏这种复杂性，操作系统把内存地址进行虚拟化，这种机制使得程序的内存大小可以灵活增减，叫做动态内存分配。早期的用户通过终端来访问计算机，终端只是键盘 + 屏幕，本身没有处理能力。一个计算机可能配备多个终端，为了确保其中一个人不会占满计算机资源，开发了分时操作系统如 Multics，即每个用户只能使用一小部分处理器资源和内存等。由于 Multics 过于复杂，又开发出了 Unix，把操作系统分成两部分，一是操作系统的核心功能，如内存管理、多任务输入/输出处理，被称为内核；二是一些有用的工具，如程序和运行库。如果内核发生错误就引发 kernel panic。现代操作系统，虽然大部分时间只有一个人在使用，但仍然有多任务、虚拟内存、内存保护的功能，因此可以同时运行多个程序。

操作系统是管理软硬件资源，合理组织调度计算机工作和资源，并向用户和其它软件提供接口和环境的系统软件（将底层硬件封装成方便易用的服务）。操作系统提供的功能包括处理机管理（如分配CPU资源给对应的进程）、存储器管理（如将程序放入内存）、文件管理（如找到对应的文件）、设备管理（如分配设备给对应的进程）

程序先要放到内存中，才能被CPU处理。

提供的服务接口如图形用户界面GUI、命令接口、程序接口。

命令接口分为联机命令接口和脱机命令接口，前者又叫交互式命令接口，用户输入一句指令系统就执行一句指令，后者又叫批处理命令接口，.bat文件。程序接口是指可以在程序中进行系统调用，用户只能通过程序代码间接使用。

没有任何软件支持的计算机称为裸机。

操作系统的特征包括：并发、共享、虚拟、异步。前两个是基本特征，且互为条件。

并发是指多个事件在同一时间间隔内发生，宏观上同时发生，微观上交替发生；而并行指多个事件在同一时刻发生。操作系统是和程序并发一起诞生的。单核CPU只能并发不能并行。共享即资源共享，系统中的资源可供内存中的多个并发执行的进程共同使用。资源共享的方式有互斥共享和同时共享两种。同时往往是宏观上的，微观上还是进程交替地访问该资源，即分时共享；互斥共享即资源在同一时间段内只能分配给其中一个进程。虚拟指把一个物理上的实体编程若干个逻辑上的对应物，后者是用户感受到的。虚拟技术中包括时分复用技术和空分复用技术。异步指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程执行走走停停，已不可预知的速度向前推进，这是进程的异步性。

分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务，各用户通过终端与计算机进行交互，用户对计算机的操作相互独立，感受不到别人的存在；但不能优先处理一些紧急任务，各个任务之间是公平的。而实时操作系统能够优先响应紧急任务，计算机要在严格的时限内处理完事件，及时可靠。

指令是处理器能识别并执行的最基本命令，是二进制机器指令。小黑框中使用的命令是交互式命令接口。

内核程序组成了操作系统内核，简称内核。CPU有两种状态，内核态（又称管态）和用户态（又称目态），处于内核态则说明正在运行内核程序，此时可以执行特权指令；处于用户态则说明正在运行用户程序，只能执行非特权指令。CPU中的程序状态寄存器PSW用于存放此时的状态。开机时CPU处于内核态，在合适的时候主动出让CPU资源，让该应用程序上CPU运行；出让之前会用一条特权指令把PSW置为用户态。

CPU发现接下来要执行的指令是特权指令，但又处于用户态时，会引发中断信号。检测到中断信号后，会立即变为内核态并停止当前的应用程序、处理中断信号；即中断会使内核重新夺回CPU的控制权（硬件自动完成状态转换）。中断处理结束之后再把CPU使用权交还应用程序。中断是让操作系统夺回CPU使用权的唯一途径。中断分为内中断和外中断，内中断与当前执行的指令有关，又称异常；而外中断与当前执行的指令无关，又称中断，如IO中断，时钟中断等。

应用程序想请求操作系统内核的服务时，会执行陷入指令，引发一个内中断信号。执行陷入指令意味着应用程序主动将CPU控制器还给操作系统内核，系统调用是通过陷入指令完成的。CPU检测到中断信号时，会根据中断类型去查询中断向量表，以此来找到中断处理程序在内存中的存放位置。

系统调用是操作系统提供给应用程序使用的接口，是可供应用程序调用来获得操作系统内核服务的特殊函数。系统调用按功能可以大致分为五类：设备管理、文件管理、进程控制、进程通信、内存管理。设备管理完成设备的请求/释放/启动等；文件管理完成文件的读写/创建/删除等；进程控制完成进程的创建/撤销/阻塞/唤醒等；进程通信完成进程之间的消息和信号传递等；内存管理完成内存的分配/回收/释放等。

操作系统需要对共享资源进行统一管理并向上提供系统调用，用户进程需要使用共享资源时，就通过系统调用向操作系统内核发出请求，内核会对各个请求进行协调处理。凡是与共享资源有关的操作，会直接影响到其它进程的操作，就一定需要操作系统介入，也就需要系统调用来实现。

由于系统中的各种共享资源都由操作系统内核统一掌管，因此范式与共享操作相关的操作，如存储分配、IO操作、文件管理等，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成，可以保证系统的稳定性和安全性，防止用户的非法操作。

系统调用的过程分为：传参、执行陷入指令trap（用户态）、由操作系统内核程序处理系统调用请求（内核态）、返回应用程序。

处理器内核能否运行一个操作系统，关键在于这个内核架构是否在操作系统内核支持的架构中，并且内存充足。

实现操作系统内核功能的那部分程序称为内核程序，大致包括时钟管理、中断处理、以及系统资源管理的功能（进程管理、存储器管理、设备管理）。原语是操作系统中处于操作系统最底层最接近硬件的部分，其运行具有原子性，只能一气呵成不可中断，运行时间较短，调用频繁。

操作系统体系结构分大内核和微内核两种，微内核是指内核只包含时钟管理、中断处理和原语（设备驱动、CPU切换等）的结构，大内核是指内核除了包含微内核外，还包含进程管理、存储器管理和设别管理等功能的结构。总的来说，大内核将操作系统的主要功能都作为系统内核、运行在核心态；微内核只把最基本的功能保留在内核。由于不用频繁切换核心态和用户态，大内核的运行性能相对更高；但相应的，内核代码更庞大，结构更复杂，难以维护。

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250928192650553.png)

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250928192716549.png)

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250928193532278.png)

程序是静态的，是一个存放在磁盘里的可执行文件；而进程是动态的，是程序的一次执行过程。进程的组成——PCB：当进程被创建时，操作系统会为该进程分配一个唯一的进程ID（PID），此外还需要记录进程所属的用户ID（UID），还需要记录给进程分配了哪些资源（分配了多少内存、正在使用哪些IO设备，使用哪些文件等），还需要记录进程运行的情况（CPU使用时间、磁盘使用情况、网络流量使用情况等），这些信息被保存在一个数据结构PCB（Process Control Block，进程控制块），用于对各个并发运行的进程进行管理。PCB是进程存在的唯一表示，当进程被创建