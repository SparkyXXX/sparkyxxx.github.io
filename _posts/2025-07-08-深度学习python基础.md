---
title: 深度学习python基础
description: 开发环境、基本语法和常用库
author: Hatrix
date: 2025-07-08 16:55:00 +0800
categories: [知识储备]
tags: [机器学习]
math: true
mermaid: true
pin: false
image:
  path: https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250708170226830.png
  alt: 深度学习基础
---

## 虚拟环境

安装的 python，主要包含了 Lib 库(包含标准库和 site-packages 第三方包存储位置)、Scripts(包含 pip.exe 包管理器)以及 python.exe 解释器；安装的时候还安装了 python 启动器(用于管理多个不同版本的 python)。虚拟环境即将上面的东西复制一份(一般情况下不含标准库，标准库通过符号链接或直接引用系统 python 安装路径下的标准库；但 anaconda 出于环境隔离的考虑，会将标准库一并复制；以及会将解释器和包管理器统一放在 Scripts 路径下，主要是为了方便添加环境变量)。

虚拟环境本质上是对解释器、包管理器的一种隔离式复制；虚拟环境的激活和去激活就是在环境变量 Path 中添加或去除虚拟环境的解释器路径，相当于对安装位置默认的路径进行截胡。在虚拟环境下安装第三方库，就会安装到虚拟环境的路径下了。

## Anaconda 使用

安装 Anaconda 后，终端或命令提示符会被修改为每次启动自动激活虚拟环境：

1. 调用 powershell.exe

2. 执行 conda shell.powershell hook
3. 通过 hook 输出的脚本定义 activate 命令
4. 自动执行 conda activate your-env
5. 显示 (your-env) 前缀

Anaconda Prompt 本质上是一个 CMD 命令行 + 初始化脚本。它启动时根据使用的 shell 调用不同的脚本，然后设置好 `PATH` 等环境变量，并激活 `(base)` 环境。

- `bash` 用 `conda.sh`
- `cmd` 用 `activate.bat`
- `powershell` 用 `conda-hook.ps1`

`base` 是 Anaconda 安装后默认创建的虚拟环境，为了让用户开箱即用，默认在终端启动时就激活 base 环境。如果不激活任何虚拟环境，就在操作系统本地的环境(也叫 "系统 Python" 或 "裸机环境")中，容易造成 依赖污染、库版本冲突、难以迁移项目 Denham 问题，这正是虚拟环境存在的原因。

`conda activate` 是一个 shell 函数/脚本。实际效果如下

1. 修改 PATH 环境变量：把虚拟环境的 `Scripts/`、`Library/bin/` 加入 PATH
2. 设置一些环境变量：比如 `CONDA_DEFAULT_ENV`, `CONDA_PREFIX`
3. 切换 Python 可执行路径：让运行的 `python` 实际指向虚拟环境中的那个

## Python 语法和最佳实践

1. “>”为大端序列，"<"为小端序列

2. 函数传参时如果按照顺序，是不用写参数名称的，反之则需要显式写出参数名

3. self 相当于类当中的一个全局变量

   类里面，\_\_init\_\_首先把参数全读进来，以后\_\_init\_\_都用 self.xxx 而不用传入的参数

   \_\_call\_\_方法：用括号加参数，而不用方法+括号和方法的语法糖

4. 加下划线的属性表示不建议外部直接访问

## 常用包

1. np_array 的图片是 HWC(height，width，channel)，用 shape 属性可以查看；cv.imread 得到的是 ndarray

2. os.system 函数可以将字符串转化成命令在服务器上运行；其原理是每一条 system 函数执行时，其会创建一个子进程在系统上执行命令行，子进程的执行结果无法影响主进程。

3. argparse 用于解析命令行参数，argparse 使用主要有四个步骤：

   - 导入`argparse`包
   - 创建 `ArgumentParser()` 参数对象
   - 调用 `add_argument()` 方法往参数对象中添加参数
   - 使用 `parse_args()` 解析添加参数的参数对象，获得解析对象
   - 程序其他部分，当需要使用命令行参数时，使用`解析对象.参数`获取

   add_argument 方法的参数

   - name or flags - 选项字符串的名字或者列表，例如 foo 或者 -f, --foo。
   - action - 命令行遇到参数时的动作，默认值是 store。如果在命令行中 加了这个参数，那么对应的变量值就会被设为 `True`；没写这个参数，则默认是 `False`
   - required - 可选参数是否可以省略 (仅针对可选参数)。

   通过在参数名前加`--`，设置为可选参数，如果未输入，则使用`default`默认值(若未设置`default`，则会默认赋值`None`)。通过将可选参数设置引用名，可以缩短参数名，简化命令行参数输入。

4.

## Pytorch 使用

1. 加载数据：pytorch 中的数据主要是两个类型，一个是 dataset，一个是 dataloader。dataset 提供一种获取数据及其 labl 并进行编号的方式，dataloader 用于打包数据成 batch 并为后面的网络提供不同的数据形式。dataset 实现的功能包括如何获取每一个数据及其 label、提供数据总数。根据数据集的组织形式实现自己的 dataset，包括\_\_init\_\_，\_\_getitem\_\_，\_\_len\_\_三个方法。dataloader 用于定义数据加载方式，常用参数包括 dataset、batch_size、shuffle、num_workers、drop_last
2. tensorboard 可以画出训练损失图，可以查看数据集中的图片
3. transforms：对图片进行变换，Compose 组合(传入 transform 列表，注意前一个输出个后一个输入类型匹配)、ToTensor 转为张量、Normalize 归一化、Resize 尺寸变化、CenterCrop 中心裁剪。transforms 相当于一个工具箱，使用之前需要先通过里面的类创建自己的工具，然后使用这个工具。
4. nn.Module：作为基类，子类继承它并实现\_\_init\_\_和 forward 方法
5. conv2d 的参数：input(四维数组，通过 reshape 增添维度)、weight(卷积核)，bias、stride、padding、dilation、groups
6. 最大池化层：下采样，作用是提取最有代表性的信息并减少参数量
7. 非线性层：ReLU、sigmoid
8. 线性层：全连接
9. Sequential 将网络各层串联起来

BA 是优化相机参数和三维点坐标，使投影误差最小化的非线性优化算法

magick 包

主流神经网络架构

验证测试：渲染测试集和部分训练集图像、计算 PSNR、L1 等指标并写入 tensorboard 日志

保存模型会将当前模型的高斯参数保存为 `.ply` 文件(用于渲染、可视化、最终发布)，通常用于导出可用于渲染或三维重建的结果。

保存 checkpoint(模型权重 + 当前迭代数)，供以后恢复训练。防止训练中断后丢失全部进度以及允许从特定训练轮数恢复继续训练。

torch.empty(0)：创建一个长度为 0 的张量，占位用，不占空间

`@property` 是 Python 的一个 **装饰器(decorator)**，用于将一个方法“伪装成”属性来使用。这样你就可以像访问属性一样使用一个函数的返回值，而不用加 `()`。

参数名: 类型注解。这不是强制类型，只是类型提示(Type Hint)

在 Windows 系统中，Python 的多进程(multiprocessing)使用`spawn`方式创建新进程，而不是类 Unix 系统的`fork`方式。这种方式要求所有创建进程的代码必须放在`if __name__ == '__main__':`语句块中，否则会导致无限递归创建进程的问题。包括使用 PyTorch 的 DataLoader 并设置了`num_workers > 0`的情况

weight 就是卷积核，通常为了保证输出大小和输入大小一致，padding 设置为 `(kernel_size - 1) // 2`，比如 5x5 就是 padding=2，3x3 就是 padding=1。

卷积层和最大池化层的输入输出尺寸均如下

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250720195421276.png)

pytorch 导入模块的最佳实践：

```python
import torch # 导入整个模块
import torch.nn as nn # 导入子模块并起别名
import torch.nn.functional as F # 导入子模块并起别名
# from torch import nn # 提取子模块并将其拉进当前作用域 (不推荐)
from torch.utils.data import DataLoader # 只导入某个函数或类并拉进当前作用域
```

pycharm 关闭拼写检查

四元数和旋转矩阵互转

3Dpoints 中的 error 指的是重投影误差

使用 `with` 是最佳实践，自动调用 `f.close()` 关闭文件，不容易出错。

“Composition over inheritance”的折中，也叫 Struct-like inheritance + method injection

```python
class Image(BaseImage):
    def qvec2rotmat(self):
        return qvec2rotmat(self.qvec)

BaseImage = collections.namedtuple(
    "Image", ["id", "qvec", "tvec", "camera_id", "name", "xys", "point3D_ids"])
```

keepdim=True，求平均的那一维不会被“压缩”掉，而是保留成长度为 1 的维度，输出形状就是 `(3, 1)`，也就是一个列向量。

浅拷贝(shallow copy)只复制最外层对象，内部嵌套的对象仍与原对象共享引用；而深拷贝(deep copy)则递归复制所有层级，确保新对象与原对象完全独立。浅拷贝适合不修改内部结构的场景，若要对复杂嵌套对象做彻底隔离，需使用深拷贝(如 `copy.deepcopy()`)，以避免“改了副本，原对象也被改”的问题。

在 Python 中，`==`用于比较两个对象的值是否相等，而`is`用于判断两个对象是否为内存中的同一个对象。对于 None，比较时应使用 `is` 而非 `==`(如 `x is None`，这是 Python 推荐的写法)

W2C 中的 tvec 表示世界坐标系原点在相机坐标系中的坐标，C2W 中的 tvec 表示相机坐标系原点在世界坐标系中的坐标

get_expon_lr_func()：带 warm-up 的指数衰减学习率调度器，这是啥？

函数形参首字母小写 fovX，类中属性首字母大写 FovX

写之前先看看设计模式和命名规范的最佳实践

## 省略的东西

1. convert.py 中去掉了 no_gpu、skip_matching、resize、colmap_executable、magick_executable 的参数接收；resize 的处理；各个 cmd 的 exit 分别的提示
2. colmap_loader.py 中去掉读取 COLMAP 输出的 txt 文件，只保留了读取 bin 的；去掉了 read_colmap_bin_array 函数
3. dataset_reader.py 中去掉对 blender 数据集的读取，去掉 readColmapSceneInfo 和 readColmapCameras 函数中对 depths 的处理，去掉 if "360" in path: llffhold = 8，去掉 fetchPly 的 try，去掉 is_nerf_synthetic(默认 False，因为现在用 COLMAP)
4. 导入 SparseGaussianAdam 失败
5. argument 的\_\_init\_\_.py 中去掉了 ModelParams 中的\_depths 参数
6. cameras.py 去掉了 MiniCam 类(只在 render 中的 network_gui.py 中用到)，去掉 Camera 类中的 depth_params 和 invdepthmap
7. camera_utils.py 的 loadCam 去掉 is_nerf_synthetic
8. 各个 transpose，令人大脑飞速旋转
9.
