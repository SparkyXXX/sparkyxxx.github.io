---
title: FPGA 入门
description: 知识储备
author: Hatrix
date: 2025-08-30 21:30:00 +0800
categories: [硬件开发]
tags: [实践技能]
math: true
mermaid: true
pin: false
image:
  path: https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20240424100647039.png
  alt: FPGA Basic
---

## FPGA 概览

FPGA 是 CLD(Configurable Logic Device，可编程逻辑设备)的一种，一般用于高质量低延迟的视频流处理，硬件加速等，其工作方式与 GPU 类似，将部分在 CPU 上由软件执行的工作 offload 到硬件电路上进行。

FPGA 的结构由可编程输入/输出单元、基本可编程逻辑单元、嵌入式块 RAM、布线资源和 IP 内核单元几部分组成。CLB(Configurable Logic Block，可配置逻辑块) 是 FPGA 的编程部分，也称逻辑单元，配置时可以只对芯片中的部分 CLB 编程，因此一块芯片可以同时执行不同的功能，或以流水线的形式在不同时刻对数据做不同的处理，故 FPGA 拥有很高的并行度。同样由于这一特性，FPGA 的设计目标之一，就是用最少的 CLB 实现需要的逻辑函数。

CLB 内部由查找表 LUT(Lookup Table)和触发器 FF(Flip-Flops)构成。LUT 是存储真值表的介质，也可用作分布式 RAM 作为快速高效的 on-chip memory。LUT 通过 SRAM 实现编程，可以反复编程且不用刷新电子。

<img src="https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250619231431328.png" alt="" style="zoom: 50%;" />

## 开发流程

FPGA 开发流程大致可以分为以下步骤：

- 设计(Design)：用 HDL 对硬件电路进行建模描述，需要定义电路功能实现、设计约束和测试用例。对于许多常用的功能，有现成的 IP 核作为轮子可以直接使用。测试用例是针对功能仿真的，由.sim 文件管理；设计约束主要由.xdc 文件管理。
- 功能仿真(Simulation)：又称前仿真，指在计算机的仿真器上运行 Verilog 代码，在不考虑硬件电路实现和绝大部分约束的情况下，仅验证逻辑功能是否正确。功能仿真是可选步骤。
- 分析和综合(Systhesis)：检查 HDL 代码是否符合综合规则，并由 EDA 在厂家提供的标准单元库和设计阶段中的约束下，编译出由 HDL 描述的逻辑网表并进行逻辑优化。逻辑网表是指一个标准的逻辑门或查找表的集合，是一个逻辑层面的结构，可以包括时序触发器、寄存器等时序元素，是逻辑门级别的描述。另外，注意不是所有的 HDL 语句都可以综合出相应的逻辑电路。
- 布局布线(Implementation)：分配引脚并确定内部电路的连接关系，进行 layout 和 IO planning，根据设计阶段的约束文件和综合出的逻辑网表，利用厂家提供的标准元件库对门级电路进行布局，在考虑各种约束和优化的情况下，将设计中的门级网表映射到 FPGA 的物理布局上并进行物理优化。完成这一步后就将 HDL 描述的模型电路转化为标准元件库组成的数字电路，且此时的电路已经包含了时延信息。
- 时序分析(Analysis)：指时序仿真，又称后仿真，用于检查信号延迟是否满足要求。时序分析有静态时序分析(STA)和动态时序分析(DTA)，静态时序分析是通过计算每条路径的延迟来检查是否满足设计的时序约束；动态时序分析是模拟设计的运行，动态检查信号的传播延迟，用于验证时序边界。时序分析是可选步骤。
- 生成比特流和板级调试(Bitstream)：生成烧录到板子中的二进制文件.bit，并进行实际硬件的调试。生成比特流之前需要完成设计、综合和布局布线。比特流文件是一种专门为 FPGA 硬件配置而设计的格式，文件内容是经过优化的、以二进制形式存储的配置信息，包含了逻辑元件的映射、时序约束、硬件资源配置等所有信息，能够直接在 FPGA 上加载和执行。

设计约束包括：

- 引脚约束：又称 IO 约束、引脚绑定，将逻辑信号与物理引脚进行对应
- 时序约束：保证各信号按预期的时序顺序传输，在规定时间内到达正确的位置，主要类型包括时钟约束、输入输出延迟约束、时序路径约束等
- 资源约束：又称面积约束，限制 FPGA 资源的使用量来适配目标 FPGA 的可用资源
- 布局约束：用于控制设计中各逻辑单元的物理布局，确保逻辑单元被放置到 FPGA 的指定资源区域内，从而提高时序性能、减少信号延迟并优化资源使用

## Verilog 基础语法

Verilog HDL(简称 Verilog)是一种硬件描述语言，用于数字电路的系统设计和仿真，同一语言可用于生成模拟激励，以及指定测试的约束条件。Verilog 可对算法级、门级、开关级等多种抽象设计层次进行建模，使用模块实例化可描述任何层次；主要有三种建模的描述风格：行为级描述——使用过程化结构建模；数据流描述——使用连续赋值语句建模；结构化方式——使用门和模块例化语句描述。

Verilog 可用 primitive 创建自定义原语(UDP)，既可以是组合逻辑，也可以是时序逻辑。Verilog 还支持其他编程语言接口(PLI)进行进一步扩展，PLI 允许外部函数访问 Verilog 模块内部信息。Verilog 的语法与 C 语言很类似，相同的语法只在此处简单罗列：区分大小写。空格没有实际意义。每个语句以分号结束。注释用双斜线。标识符的第一个字符必须是字母或者下划线。关键字是预留的用于定义语言结构的特殊标识符，Verilog 中关键字全部为小写。表达式由操作符和操作数构成，可以在出现数值的任何地方使用。操作符及其优先级顺序同 C 语言。

### 编译指令

以反引号开始的某些标识符是 Verilog 系统编译指令，编译指令的用法和 C 语言基本类似，包含条件编译指令、宏定义和取消、文件包含、时间单位指定等。

在 Verilog 模型中，时延有具体的单位时间表述，用 \`timescale 定义时延及仿真的单位和精度，将时间单位与实际时间相关联。其中 time_precision 的大小需要小于等于 time_unit 的大小。

```verilog
`timescale      time_unit / time_precision
```

由于 Verilog 中没有默认的 \`timescale，如果不显式指定，模块就有可能继承前面编译模块参数并导致设计出错。一个设计中的多个模块都带有 \`timescale 时，则 time_precision 确定为所有模块中的最小值，其它 time_precision 都相应地换算为这个精度，time_unit 不受影响。如果有并行子模块，子模块间的 \`timescale 并不会相互影响。time_precision 越小，仿真时占用内存越多，实际使用的仿真时间就越长，所以在满足需要的前提下应尽量将 time_precision 设置得大一些。

### 数值表示

Verilog 有下列四种基本的值来表示硬件电路中的电平逻辑：

- 0：逻辑 0 或 "假"
- 1：逻辑 1 或 "真"
- x 或 X：未知，信号数值的不确定
- z 或 Z：高阻，常见于信号没有驱动时的逻辑结果，其逻辑值和上下拉的状态有关系

声明数值的规范格式为位宽 + 基数 + 数值，声明数值可选择是否指明位宽，不指定时默认为十进制，建议显式指明位宽以降低调试难度。数值相同的情况下，不同基数格式完全等效。声明较长的数值建议每四位增加一个下划线以增强可读性。负数可以直接在十进制数字前加负号(如 `-5`)，也可以用二进制补码表示(如 `4'b1011` 表示 `-5` 的 4 位补码)。由于负数在硬件中使用二进制补码表示，不显式指定位宽的情况下，编译器会自动选择默认位宽，可能在赋值或截断时产生意想不到的结果，因此建议负数表示建议显式指定位宽。

```verilog
1'b0;
4'd3;
6'sd-15; 	// 负数建议显式指定位宽; s表示有符号数。
6'b11_0001; // 二进制中以补码表示，即正数部分逐位取反再加一; 二进制默认为无符号数。
```

声明变量时要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出，否则导致高位被截断造成数据丢失。如无符号数乘法的结果变量位宽应该声明为 2 个操作数的位宽之和。

### 数据类型

在 verilog 中，变量分为网线型(net)和过程型(variable)两类。net 用于表示信号的物理连接，必须由驱动源(门、模块输出、连续赋值 assign)来驱动；variable 只能在过程块中被赋值，有阻塞赋值=和非阻塞赋值<=。最常用的网线型变量和过程型变量分别是 wire 和 reg，其余类型可以理解为这两种数据类型的扩展或辅助，并且在入门阶段均不常见，此处不作介绍。wire 和 reg 变量与赋值方式联系较为紧密，后续一并介绍。

当位宽大于 1 时，变量会被声明为向量的形式，可以通过索引或指定 bit 位后固定位宽的向量域选定向量的某一位或若干相邻位进行操作，语法为[bit+: width]或[bit-: width]，表示从起始 bit 位开始递增或递减 width 位。此外，Verilog 支持可变的向量域选择。

```verilog
reg [31:0] data1;
reg [7:0] byte1 [3:0]; // byte1 是一个 4 字节(数组)的存储器，每个元素都是 8 位宽的寄存器

// 指定向量域
A = data1[31:24];
A = data1[31-:8];
B = data1[0:7];
B = data1[0+:8]

// 用大括号可将信号组合成向量
wire [31:0] temp1, temp2;
assign temp1 = {byte1[0][7:0], data1[31:8]};
assign temp2 = {32{1'b0}};

//把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]
always @(*) begin
    for (int j=0; j<=3; j++) begin
        byte1[j] = data1[(j+1)*8-1 : j*8];
    end
end
```

在 Verilog 中允许声明 reg, wire, int, time, real 及其向量类型的数组。数组维数没有限制。数组中的每个元素都可以作为一个标量或者向量，形如：<数组名>[<下标>]。多维数组需要说明其每一维的索引。数组与向量的访问方式在一定程度上类似，但两者是截然不同的数据结构。向量是一个单独的元件，位宽为 n；数组由多个元件组成，其中每个元件的位宽为 n 或 1，比如存储器变量就是用于描述 RAM 或 ROM 行为的寄存器数组。

```verilog
integer flag[7:0];
reg [3:0] counter[3:0];
wire [7:0] addr_bus[3:0];
wire data_bit[7:0][5:0];
reg [31:0] data_4d[11:0][3:0][3:0][255:0];

flag[1] =  32'd0;
counter[3] = 4'hF;
assign addr_bus[0] = 8'b0;
assign data_bit[0][1] = 1'b0;
data_4d[0][0][0][0][15:0] = 15'd3;
```

整数类型用关键字 integer 或 int 声明，是有符号数，声明时位宽和编译器有关(一般为 32 bit)。实数类型用关键字 real 声明，可用十进制或科学计数法来表示，默认值为 0，不能指定位宽，因为 real 在计算机内部为双精度浮点数，位宽固定为 64 位。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。

```verilog
real data1;
integer temp;
initial begin
    data1 = 2e3;
    data1 = 3.75;
end

initial begin
    temp = data; // temp = 3
end
```

time 型变量为 Verilog 中特殊的时间寄存器，用于保存仿真时间，其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。

```verilog
time current_time
initial begin
    #100
    current_time = $time;
end
```

参数用来表示常量，用关键字 parameter 声明，只能赋值一次。通过实例化的方式，可以更改参数在模块中的值。当参数只在本模块中调用时，可用局部参数 localparam 来声明，其作用和用法与 parameter 相同，区别在于它的值不能被改变。

```verilog
parameter data_width = 10'd32;
parameter i=1, j=2, k=3;
parameter mem_size = data_width * 10;
```

字符串是由双引号包起来的单字节(8bit) ASCII 字符队列，保存在 reg 类型的变量中。注意寄存器变量的宽度应该足够大以保证不会溢出，如果寄存器变量的宽度大于字符串的大小，则使用 0 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。

```verilog
reg [0:14*8-1] str;
initial begin
    str = "www.runoob.com";
end
```

### 操作数和操作符

只介绍 C 语言中没有或存在差异的部分。

- 操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数，比如过程块中不能为 wire 类型变量赋值。

- 算术操作符和关系操作符中，如果操作数某一位为 x，则计算结果为 x。

- 逻辑操作符的计算结果是一个 1bit 的值。如果一个操作数不为 0，则等价于逻辑 1；如果一个操作数等于 0，则等价于逻辑 0。如果它任意一位为 x 或 z，则等价于 x。

- \=\=\=(全等运算符)不做类型转换，值和数据类型都相同，才返回 true。\=\=(相等运算符)先尝试类型转换，把不同类型的值转成同一类型后再比较值是否相等，推荐使用更安全的===来减少 bug 风险。全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1；因此全等比较的结果一定不包含 x。

- 按位操作符对 2 个操作数的每 1bit 数据进行按位操作。如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。

- 归约操作符只有一个操作数，作用是对单个向量操作数进行逐位操作，最终得到 1 位结果 ，常用来判断向量中某些位的整体特征(如是否全 1、是否有 1 等)。

- 部分逻辑操作符、按位操作符和归约操作符使用相同的符号表示，由作用的操作数数量和计算结果(即上下文)加以区分。

- 拼接操作符用大括号 {A, B} 来表示，用于将多个操作数拼接成新的操作数，信号间用逗号隔开。拼接符操作数必须指定位宽，常数也需要指定位宽。

- “左移” 一般默认指逻辑左移，逻辑左移和算术左移的区别在于对有符号数符号位的处理。逻辑左移将二进制数当无符号数处理，所有位包括最高位均左移，右侧补 0；算术左移将二进制数当有符号数处理，保留符号位不变仅对数值位左移，右侧补 0。逻辑右移和算术右移类似，逻辑右移时左边高位补 0；算术右移时左边高位补符号位，以保证数据缩小后值的正确性。

- 条件操作符可以嵌套以实现多次选择的逻辑

  ```verilog
  assign   hsel = (addr[9:8] == 2'b00) ? hsel_p1 :
                  (addr[9:8] == 2'b01) ? hsel_p2 :
                  (addr[9:8] == 2'b10) ? hsel_p3 :
                  (addr[9:8] == 2'b11) ? hsel_p4 ;
  ```

### 赋值方式

Verilog 中有连续赋值和过程赋值两类赋值方式。对于简单的组合逻辑，用连续赋值可以建模；对于复杂组合逻辑和时序逻辑，则需要使用过程赋值。在介绍两种赋值方式前，需要先集中介绍 wire 和 reg 两种数据类型。

- wire 表示硬件单元之间的物理连线，用于连接驱动源(提供值的地方)和被驱动端口(接收值的地方)，抽象为电路中的导线。wire 由其连接的器件输出端连续驱动，即驱动源变化，wire 立即变化。典型的驱动源包括原语/模块的输出、连续复制语句 assign 等。没有驱动元件连接到 wire 型变量时，其缺省值为 "Z"。wire 可以在定义时赋值或定义后用 assign 赋值；但无论哪种方式，由于 wire 型变量由其它电路驱动，每个 wire 变量最多只能有一个驱动源，因此只能被赋值一次。
- reg 表示存储单元，会保持数据原有的值直到被改写，不需要驱动源。reg 是过程变量，由过程块赋值；反过来，在 initial 或 always 这样的过程块中赋值的变量需要声明为 reg 类型。初始化的 reg 在仿真开始为 X，默认为无符号数。reg 在时钟敏感表的过程块中赋值时被综合为触发器，而在组合敏感的过程块中赋值，且所有分支对它都有输出时，被综合成组合逻辑网络(即门电路+导线)。如果组合逻辑中存在没有赋值的分支，则会综合出锁存器，这是入门阶段最容易踩的坑。

除此之外还需要引出过程块的概念：过程块是一段顺序执行的代码块，一次性封装一系列语句，并在特定条件触发时，执行一次块中的语句；过程块包括`initial ... end`、`always @`、`always @*`三种，块中不能为 wire 类型变量赋值。敏感表即过程块中括号部分的内容，是一个描述触发条件的列表，其作用是明确哪些信号发生变化时，需要触发执行这个过程块。敏感表分为组合敏感表和时钟敏感表两类，分别用于描述组合逻辑和时序逻辑。写错敏感表可能导致仿真和综合结果不一致。另外，连续赋值由硬件电路自动驱动，不需要敏感表。

连续赋值适合建模硬件导线关系，始终生效，必须驱动 wire 类型。连续赋值代表并行的硬件，总是处于激活状态，任何操作数的改变都会影响表达式的结果。

过程赋值适合建模复杂逻辑关系和时序逻辑，必须出现在过程块中且必须用 reg 类型变量。这些变量在被赋值后，其值将保持不变，直到重新被赋予新值。过程赋值只有在语句执行的时候，才会起作用。

过程赋值包括两种语句：阻塞赋值与非阻塞赋值。阻塞赋值(=)属于顺序执行语句，即下一条语句执行前，当前语句一定会执行完毕。在过程块中会立即更新目标变量的值。非阻塞赋值(<=)属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。在时钟沿触发的过程块中，非阻塞赋值不会立即生效，在当前时钟周期结束时才进行赋值。

如下面的例子，两个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a<=b 与 b<=a 就可以相互不干扰的执行，达到交换寄存器值的目的。

```verilog
always @ (posedge clk) begin
	a <= b;
end

always @ (posedge clk) begin
    b <= a;
end
```

实际 Verilog 代码设计时，切记不要在一个过程结构中混合使用阻塞赋值与非阻塞赋值。两种赋值方式混用时，时序不容易控制，很容易得到意外的结果。更多时候，在设计电路时，always 时序逻辑块中多用非阻塞赋值，always 组合逻辑块中多用阻塞赋值；在仿真电路时，initial 块中一般多用阻塞赋值。

### 过程结构

过程结构语句是行为级建模的两种基本语句，有 initial 和 always 两种。一个模块中可以包含多个 initial 和 always 语句，由于语句本身代表独立的过程，每个语句会产生一个独立的控制流，执行时间均从 0 时刻开始，因此 initial 和 always 均不支持嵌套。这些语句在模块间并行执行，与其在模块的前后顺序没有关系；但 initial 语句或 always 语句内部是顺序执行的(非阻塞赋值除外)。

initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。initial 理论上来讲是不可综合的，多用于初始化、信号检测等。

与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。

### 时序控制

介绍时序控制前，需要先介绍时延的概念。

连续赋值语句中的延时，用于控制任意操作数发生变化到语句左端赋予新值之间的时间延时。连续赋值时延一般可分为普通赋值时延、隐式时延、声明时延。寄存器的时延也是可以控制的，这部分在时序控制里加以说明。时延的值可以是数字、标识符或者表达式。时延一般是不可综合的。下面 3 个例子实现的功能是等效的，分别对应 3 种不同连续赋值时延的写法。

```verilog
//普通时延，A&B计算结果延时10个时间单位赋值给Z
wire Z, A, B;
assign #10 Z = A & B;

//隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。
wire A, B;
wire #10 Z = A & B;

//声明时延，声明一个wire型变量时指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。
wire A, B;
wire #10 Z;
assign Z = A & B;
```

在上述例子中，A 或 B 任意一个变量发生变化，那么在 Z 得到新的值之前，会有 10 个时间单位的时延。如果在这 10 个时间单位内，即在 Z 获取新的值之前，A 或 B 任意一个值又发生了变化，那么计算 Z 的新值时会取 A 或 B 当前的新值。所以称之为惯性时延，即信号脉冲宽度小于时延时，对输出没有影响。因此仿真时，时延一定要合理设置，防止某些信号不能进行有效的延迟。

Verilog 提供了两大类时序控制方法：时延控制和事件控制。基于时延的时序控制出现在表达式中，它指定了语句从开始执行到执行完毕之间的时间间隔。事件控制主要分为边沿触发事件控制与电平敏感事件控制。

根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。遇到常规延时时，该语句需要等待一定时间，然后将计算结果赋值给目标信号。遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。内嵌时延控制加在赋值号之后。

```verilog
// 常规时延
reg value_test, value_general;
# 10 value_general = value_test;
// 内嵌时延
reg value_test, value_embed;
value_embed = # 10 value_test;
```

当延时语句的赋值符号右端是常量时，两种时延控制都能达到相同的延时赋值效果。当延时语句的赋值符号右端是变量时，两种时延控制可能会产生不同的延时赋值效果。常规时延赋值方式：遇到延迟语句后先延迟一定的时间，然后将当前操作数赋值给目标信号，并没有"惯性延迟"的特点，不会漏掉相对较窄的脉冲。内嵌时延赋值方式：遇到延迟语句后，先计算出表达式右端的结果，然后再延迟一定的时间，赋值给目标信号。

---

事件控制

边沿触发事件控制

在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。基于事件触发的时序控制又主要分为以下几种。

一般事件控制

事件控制用@表示，语句执行的条件是信号的值发生特定的变化。关键字 posedge 指信号发生边沿正向跳变，negedge 指信号发生负向边沿跳变，未指明跳变方向时，则 2 种情况的边沿变化都会触发相关事件。例如：

```verilog
always @ (clk) q <= d; // 信号clk只要发生变化，就执行q<=d，双边沿D触发器模型
always @ (posedge clk) q <= d; //在信号clk上升沿时刻，执行q<=d，正边沿D触发器模型
always @ (negedge clk) q <= d; //在信号clk下降沿时刻，执行q<=d，负边沿D触发器模型

q = @ (posedge clk) d; //立刻计算d的值，并在clk上升沿时刻赋值给q，不推荐这种写法
```

不推荐最后一种写法的原因是，=是阻塞赋值，不符合常规的过程赋值语法规范，即阻塞赋值通常用于组合逻辑或明确的 “立即执行” 场景。事件控制更常见于 always 块的敏感列表或 always 块内的时序控制。若在 `initial` 块或普通 `always` 块(非时序逻辑专用的 `always` 块)中使用，容易打破 “组合逻辑并行、时序逻辑同步触发” 的设计习惯；若在复杂场景(如多个信号交互、多时钟域)中使用，会导致仿真行为与硬件电路的实际并行执行逻辑脱节。Verilog 中，时序逻辑(如 D 触发器)的标准写法是用 `always` 块 + 非阻塞赋值(`<=`)

命名事件控制

用户可以声明 event(事件)类型的变量，并触发该变量来识别该事件是否发生。命名事件用关键字 event 来声明，触发信号用 -> 表示。

```verilog
event start_receiving;
always @ (posedge clk_sample) begin
    -> start_receiving;
end

always @ (start_receiving) begin
    data_buf = {data_if[0], data_if[1]};
end
```

当多个信号或事件中任意一个发生变化都能够触发语句的执行时，Verilog 中使用"或"表达式来描述这种情况，用关键字 or 连接多个事件或信号。这些事件或信号组成的列表称为"敏感列表"。当然，or 也可以用逗号 , 来代替。例如：

```verilog
always @ (posedge clk or negedge rstn) begin
    if (!rstn) begin
    	q <= 1'b;
    end
    else begin
    	q <= d;
    end
end
```

当组合逻辑输入变量很多时，那么编写敏感列表会很繁琐。此时，更为简洁的写法是 @\* 或 @(\*)，表示对语句块中的所有输入变量的变化都是敏感的。例如：

```verilog
always @ (*) begin
	assign s = a ? b+c : d ? e+f
end
```

电平敏感事件控制

前面所讨论的事件控制都是需要等待信号值的变化或事件的触发，使用 @+敏感列表 的方式来表示的。

Verilog 中还支持使用电平作为敏感信号来控制时序，即后面语句的执行需要等待某个条件为真。Verilog 中使用关键字 wait 来表示这种电平敏感情况。例如：

```verilog
initial begin
    wait (start_enable);
    forever begin
        @ (posedge clk_sample);
    	data_buf = {data_if[0], data_if[1]};
	end
end
```

### 语句块

Verilog 语句块提供了将两条或更多条语句组成语法结构上相当于一条一句的机制。主要包括两种类型：顺序块和并行块。顺序块用关键字 begin 和 end 来表示。顺序块中的语句是一条条执行的。当然，非阻塞赋值除外。顺序块中每条语句的时延总是与其前面语句执行的时间相关。并行块有关键字 fork 和 join 来表示。并行块中的语句是并行执行的，即便是阻塞形式的赋值。并行块中每条语句的时延都与块语句开始执行的时间相关。顺序块和并行块还可以嵌套使用。

可以给块语句结构命名。命名的块中可以声明局部变量，通过层次名引用的方法对变量进行访问。

```verilog
`timescale 1ns/1ns

module test;

    initial begin: runoob   //命名模块名字为runoob，分号不能少
        integer    i ;       //此变量可以通过test.runoob.i 被其他模块使用
        i = 0 ;
        forever begin
            #10 i = i + 10 ;
        end
    end

    reg stop_flag ;
    initial stop_flag = 1'b0 ;
    always begin : detect_stop
        if ( test.runoob.i == 100) begin //i累加10次，即100ns时停止仿真
            $display("Now you can stop the simulation!!!");
            stop_flag = 1'b1 ;
        end
        #10 ;
    end

endmodule
```

命名的块也可以被禁用，用关键字 disable 来表示。disable 可以终止命名块的执行，可以用来从循环中退出、处理错误等。与 C 语言中 break 类似，但是 break 只能退出当前所在循环，而 disable 可以禁用设计中任何一个命名的块。disable 可退出当前的 while 块。需要说明的是，disable 在 always 或 forever 块中使用时只能退出当前回合，下一次语句还是会在 always 或 forever 中执行。因为 always 块和 forever 块是一直执行的，此时的 disable 有点类似 C 语言中的 continue 功能。

==always 和 forever 的区别==

```verilog
`timescale 1ns/1ns

module test;

    initial begin: runoob_d //命名模块名字为runoob_d
        integer    i_d ;
        i_d = 0 ;
        while(i_d<=100) begin: runoob_d2
            # 10 ;
            if (i_d >= 50) begin       //累加5次停止累加
                disable runoob_d3.clk_gen ;//stop 外部block: clk_gen
                disable runoob_d2 ;       //stop 当前block: runoob_d2
            end
            i_d = i_d + 10 ;
        end
    end

    reg clk ;
    initial begin: runoob_d3
        while (1) begin: clk_gen  //时钟产生模块
            clk=1 ;      #10 ;
            clk=0 ;      #10 ;
        end
    end

endmodule
```

### 条件语句

```verilog
if (condition1)       true_statement1 ;
else if (condition2)        true_statement2 ;
else if (condition3)        true_statement3 ;
else                      default_statement ;
```

如果要执行多条语句，使用 begin 和 end 即可。事例中 if 条件每次执行的语句只有一条，没有使用 begin 与 end 关键字。但如果是 if-if-else 的形式，即便执行语句只有一条，不使用 begin 与 end 关键字也会引起歧义。当然，编译器一般按照就近原则，使 else 与最近的一个 if(例子中第二个 if)相对应。但显然这样的写法是不规范且不安全的。所以条件语句中加入 begin 与 and 关键字就是一个很好的习惯。

### 多路分支语句

```verilog
case(case_expr)
    condition1     :             true_statement1 ;
    condition2     :             true_statement2 ;
    ……
    default        :             default_statement ;
endcase
```

default 语句是可选的，且在一个 case 语句中不能有多个 default 语句。条件选项可以有多个，不仅限于 condition1、condition2 等，而且这些条件选项不要求互斥。虽然这些条件选项是并发比较的，但执行效果是谁在前且条件为真谁被执行。ture_statement1 等执行语句可以是一条语句，也可以是多条。如果是多条执行语句，则需要用 begin 与 end 关键字进行说明。case 语句支持嵌套使用。case 语句中的条件选项表单式不必都是常量，也可以是 x 值或 z 值。当多个条件选项下需要执行相同的语句时，多个条件选项可以用逗号分开，放在同一个语句块的候选项中。但是 case 语句中的 x 或 z 的比较逻辑是不可综合的，所以一般不建议在 case 语句中使用 x 或 z 作为比较值。

```verilog
case(sel)
    2'b00:   sout_t = p0 ;
    2'b01:   sout_t = p1 ;
    2'b10:   sout_t = p2 ;
    2'b11:     sout_t = p3 ;
    2'bx0, 2'bx1, 2'bxz, 2'bxx, 2'b0x, 2'b1x, 2'bzx :
        sout_t = 2'bxx ;
    2'bz0, 2'bz1, 2'bzz, 2'b0z, 2'b1z :
        sout_t = 2'bzz ;
    default:  $display("Unexpected input control!!!");
endcase
```

casex、 casez 语句是 case 语句的变形，用来表示条件选项中的无关项。

casex 用 "x" 来表示无关值，casez 用问号 "?" 来表示无关值。

两者的实现的功能是完全一致的，语法与 case 语句也完全一致。

但是 casex、casez 一般是不可综合的，多用于仿真。

### 循环语句

Verilog 循环语句有 4 种类型，分别是 while，for，repeat，和 forever 循环。循环语句只能在 always 或 initial 块中使用，但可以包含延迟表达式。当然，执行语句只有一条时，关键字 begin 与 end 可以省略。需要注意的是，i = i + 1 不能像 C 语言那样写成 i++ 的形式，i = i -1 也不能写成 i -- 的形式。repeat 的功能是执行固定次数的循环，它不能像 while 循环那样用一个逻辑表达式来确定循环是否继续执行。repeat 循环的次数必须是一个常量、变量或信号。如果循环次数是变量信号，则循环次数是开始执行 repeat 循环时变量信号的值。即便执行期间，循环次数代表的变量信号值发生了变化，repeat 执行次数也不会改变。forever 语句表示永久循环，不包含任何条件表达式，一旦执行便无限的执行下去，系统函数 $finish 可退出 forever。forever 相当于 while(1) 。通常，forever 循环是和时序控制结构配合使用的。

```verilog
while (condition) begin
    …
end

for(initial_assignment; condition ; step_assignment)  begin
    …
end

repeat (loop_times) begin
    …
end

forever begin
    …
end
```

使用 forever 语句产生一个时钟：

```verilog
~timescale 1ns / 1ns
reg clk;
initial begin
	clk = 0;
    forever begin
    	#5 clk = ~clk;
    end
end
```

### 过程连续赋值

==这一节没咋看懂==

过程连续赋值是过程赋值的一种。这种赋值语句能够替换其他所有 wire 或 reg 的赋值，改写了 wire 或 reg 型变量的当前值。与过程赋值不同的是，过程连续赋值的表达式能被连续的驱动到 wire 或 reg 型变量中，即过程连续赋值发生作用时，右端表达式中任意操作数的变化都会引起过程连续赋值语句的重新执行。过程连续性赋值主要有 2 种，assign-deassign 和 force-release。

assign(过程赋值操作)与 deassign (取消过程赋值操作)表示第一类过程连续赋值语句。赋值对象只能是寄存器或寄存器组，而不能是 wire 型变量。赋值过程中对寄存器连续赋值，寄存器中的值被保留直到被重新赋值。

```verilog
module diff_assign(
    input rstn,
    input clk,
    input D,
    output reg Q);

    always @ (posedge clk) begin
    	Q <= D;
    end

    always @ (negedge rstn) begin
        if (!rstn) begin
        	assign Q = 1'b0; // 过程连续赋值，Q为reg型
        end
        else begin
        	deassign Q;
        end
    end
endmodule
```

force (强制赋值操作)与 release(取消强制赋值)表示第二类过程连续赋值语句。使用方法和效果，和 assign 与 deassign 类似，但赋值对象可以是 reg 型变量，也可以是 wire 型变量。因为是无条件强制赋值，一般多用于交互式调试过程，不要在设计模块中使用。当 force 作用在寄存器上时，寄存器当前值被覆盖；release 时该寄存器值将继续保留强制赋值时的值。之后，该寄存器的值可以被原有的过程赋值语句改变。当 force 作用在线网上时，线网值也会被强制赋值。但是，一旦 release 该线网型变量，其值马上变为原有的驱动值。

十进制计数器测试：

```verilog
`timescale 1ns/1ns

module test ;
    reg          rstn ;
    reg          clk ;
    reg [3:0]    cnt ;
    wire         cout ;

    counter10     u_counter (
        .rstn    (rstn),
        .clk     (clk),
        .cnt     (cnt),
        .cout    (cout));

    initial begin
        clk       = 0 ;
        rstn      = 0 ;
        #10 ;
        rstn      = 1'b1 ;
        wait (test.u_counter.cnt_temp == 4'd4) ;
        @(negedge clk) ;
        force     test.u_counter.cnt_temp = 4'd6 ;
        force     test.u_counter.cout     = 1'b1 ;
        #40 ;
        @(negedge clk) ;
        release   test.u_counter.cnt_temp ;
        release   test.u_counter.cout ;
    end

    initial begin
        clk = 0 ;
        forever #10 clk = ~ clk ;
    end

    //finish the simulation
    always begin
        #1000;
        if ($time >= 1000) $finish ;
    end

endmodule // test
```

### 模块与端口

结构建模方式有 3 类描述语句： Gate(门级)例化语句，UDP (用户定义原语)例化语句和 module (模块) 例化语句。本次主要讲述使用最多的模块级例化语句。模块是 Verilog 中基本单元的定义形式，是与外界交互的接口。

```verilog
module module_name
    #(parameter_list)
    (port_list);
    // Declarations and Statements;
endmodule
```

模块定义必须以关键字 module 开始，以关键字 endmodule 结束。模块名，端口信号，端口声明和可选的参数声明等，出现在设计使用的 Verilog 语句(图中 Declarations_and_Statements)之前。模块内部有可选的 5 部分组成，分别是变量声明，数据流语句，行为级句，低层模块例化及任务和函数，如下图表示。这 5 部分出现顺序、出现位置都是任意的。但是，各种变量都应在使用之前声明。变量具体声明的位置不要求，但必须保证在使用之前的位置。

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250619231619032.png)

端口是模块与外界交互的接口。对于外部环境来说，模块内部是不可见的，对模块的调用只能通过端口连接进行。模块的定义中包含一个可选的端口列表，一般将不带类型、不带位宽的信号变量罗列在模块声明里。一个模块如果和外部环境没有交互，则可以不用声明端口列表。

```verilog
module pad(
    DIN, OEN, PULL, DOUT, PAD);
    input DIN, OEN;
    input [1:0] PULL;
    inout PAD;
    output DOUT

    wire DIN, OEN;
    wire [1:0] PULL;
    wire PAD;
    reg DOUT;
endmodule
```

(1) 端口信号在端口列表中罗列出来以后，就可以在模块实体中进行声明了。根据端口的方向，端口类型有 3 种： 输入(input)，输出(output)和双向端口(inout)。input、inout 类型不能声明为 reg 数据类型，因为 reg 类型是用于保存数值的，而输入端口只能反映与其相连的外部信号的变化，不能保存这些信号的值。output 可以声明为 wire 或 reg 数据类型。

(2) 在 Verilog 中，端口隐式的声明为 wire 型变量，即当端口具有 wire 属性时，不用再次声明端口类型为 wire 型。但是，当端口有 reg 属性时，则 reg 声明不可省略。另外，端口方向和端口类型可以同时声明

```verilog
output reg DOUT;
```

(4) 还有一种更简洁且常用的方法来声明端口，即在 module 声明时就陈列出端口及其类型。reg 型端口要么在 module 声明时声明，要么在 module 实体中声明。

```verilog
module pad(
	input wire DIN, OEN,
    input [1:0] wire PULL,
	input wire PAD,
    output reg DOUT);
```

### 模块例化

在一个模块中引用另一个模块，对其端口进行相关连接，叫做模块例化。模块例化建立了描述的层次。信号端口可以通过位置或名称关联，端口连接也必须遵循一些规则。

命名端口连接：这种方法将需要例化的模块端口与外部信号按照其名字进行连接，端口顺序随意，可以与引用 module 的声明端口顺序不一致，只要保证端口名字与外部信号匹配即可。如果某些输出端口并不需要在外部连接，例化时 可以悬空不连接，甚至删除。一般来说，input 端口在例化时不能删除，否则编译报错，output 端口在例化时可以删除。

```verilog
full_adder u_adder0(
    .Ai(a[0]),
    .Bi(b[0]),
    .Ci(c==1'b1 ? 1'b0 : 1'b1),
    .So(so_bit0),
    .Co(co_temp[0]));
```

顺序端口连接：这种方法将需要例化的模块端口按照模块声明时端口的顺序与外部信号进行匹配连接，位置要严格保持一致。虽然代码从书写上可能会占用相对较少的空间，但代码可读性降低，也不易于调试。有时候在大型的设计中可能会有很多个端口，端口信号的顺序时不时的可能也会有所改动，此时再利用顺序端口连接进行模块例化，显然是不方便的。所以平时，建议采用命名端口方式对模块进行例化。

```verilog
full_adder1  u_adder1(
    a[1], b[1], co_temp[0], so_bit1, co_temp[1]);
```

端口连接规则：

输入端口

模块例化时，从模块外部来讲， input 端口可以连接 wire 或 reg 型变量。这与模块声明是不同的，从模块内部来讲，input 端口必须是 wire 型变量。

输出端口

模块例化时，从模块外部来讲，output 端口必须连接 wire 型变量。这与模块声明是不同的，从模块内部来讲，output 端口可以是 wire 或 reg 型变量。

输入输出端口

模块例化时，从模块外部来讲，inout 端口必须连接 wire 型变量。这与模块声明是相同的。

悬空端口

模块例化时，如果某些信号不需要与外部信号进行连接交互，我们可以将其悬空，即端口例化处保留空白即可，上述例子中有提及。

output 端口正常悬空时，我们甚至可以在例化时将其删除。

input 端口正常悬空时，悬空信号的逻辑功能表现为高阻状态(逻辑值为 z)。但是，例化时一般不能将悬空的 input 端口删除，否则编译会报错。一般来说，建议 input 端口不要做悬空处理，无其他外部连接时赋值其常量。

当例化端口与连续信号位宽不匹配时，端口会通过无符号数的右对齐或截断方式进行匹配。

连接端口的信号类型可以是，1)标识符，2)位选择，3)部分选择，4)上述类型的合并，5)用于输入端口的表达式。信号名字可以与端口名字一样，但他们的意义是不一样的，分别代表的是 2 个模块内的信号。

当例化多个相同的模块时，一个一个的手动例化会比较繁琐。用 generate 语句进行多个模块的重复例化，可大大简化程序的编写过程。

==没懂 generate 用法==

```verilog
module full_adder4(
    input [3:0]   a ,   //adder1
    input [3:0]   b ,   //adder2
    input         c ,   //input carry bit

    output [3:0]  so ,  //adding result
    output        co    //output carry bit
    );

    wire [3:0]    co_temp ;
    //第一个例化模块一般格式有所差异，需要单独例化
    full_adder1  u_adder0(
        .Ai     (a[0]),
        .Bi     (b[0]),
        .Ci     (c==1'b1 ? 1'b1 : 1'b0),
        .So     (so[0]),
        .Co     (co_temp[0]));

    genvar        i ;
    generate
        for(i=1; i<=3; i=i+1) begin: adder_gen
        full_adder1  u_adder(
            .Ai     (a[i]),
            .Bi     (b[i]),
            .Ci     (co_temp[i-1]), //上一个全加器的溢位是下一个的进位
            .So     (so[i]),
            .Co     (co_temp[i]));
        end
    endgenerate

    assign co    = co_temp[3] ;

endmodule
```

层次访问：每一个例化模块的名字，每个模块的信号变量等，都使用一个特定的标识符进行定义。在整个层次设计中，每个标识符都具有唯一的位置与名字。Verilog 中，通过使用一连串的 . 符号对各个模块的标识符进行层次分隔连接，就可以在任何地方通过指定完整的层次名对整个设计中的标识符进行访问。层次访问多见于仿真中。

### 带参数例化

==摘抄==

当一个模块被另一个模块引用例化时，高层模块可以对低层模块的参数值进行改写。这样就允许在编译时将不同的参数传递给多个相同名字的模块，而不用单独为只有参数不同的多个模块再新建文件。

参数覆盖有 2 种方式：1)使用关键字 defparam，2)带参数值模块例化。

可以用关键字 defparam 通过模块层次调用的方法，来改写低层次模块的参数值。

```verilog
module  ram_4x4
    (
     input               CLK ,
     input [4-1:0]       A ,
     input [4-1:0]       D ,
     input               EN ,
     input               WR ,    //1 for write and 0 for read
     output reg [4-1:0]  Q    );

    parameter        MASK = 3 ;

    reg [4-1:0]     mem [0:(1<<4)-1] ;
    always @(posedge CLK) begin
        if (EN && WR) begin
            mem[A]  <= D & MASK;
        end
        else if (EN && !WR) begin
            Q       <= mem[A] & MASK;
        end
    end

endmodule
```

```verilog
//instantiation
defparam     u_ram_4x4.MASK = 7 ;
ram_4x4    u_ram_4x4
    (
        .CLK    (clk),
        .A      (a[4-1:0]),
        .D      (d),
        .EN     (en),
        .WR     (wr),    //1 for write and 0 for read
        .Q      (q)    );
```

第二种方法就是例化模块时，将新的参数值写入模块例化语句，以此来改写原有 module 的参数值。

```verilog
module  ram
    #(  parameter       AW = 2 ,
        parameter       DW = 3 )
    (
        input                   CLK ,
        input [AW-1:0]          A ,
        input [DW-1:0]          D ,
        input                   EN ,
        input                   WR ,    //1 for write and 0 for read
        output reg [DW-1:0]     Q
     );

    reg [DW-1:0]         mem [0:(1<<AW)-1] ;
    always @(posedge CLK) begin
        if (EN && WR) begin
            mem[A]  <= D ;
        end
        else if (EN && !WR) begin
            Q       <= mem[A] ;
        end
    end

endmodule
```

```verilog
ram #(.AW(4), .DW(4))
    u_ram
    (
        .CLK    (clk),
        .A      (a[AW-1:0]),
        .D      (d),
        .EN     (en),
        .WR     (wr),    //1 for write and 0 for read
        .Q      (q)
     );
```

(1) 和模块端口实例化一样，带参数例化时，也可以不指定原有参数名字，按顺序进行参数例化

(2) 当然，利用 defparam 也可以改写模块在端口声明时声明的参数，利用带参数例化也可以改写模块实体中声明的参数

(3) 那能不能混合使用这两种模块参数改写的方式呢？当然能！前提是所有参数都是模块在端口声明时声明的参数或参数都是模块实体中声明的参数。

(4) 那如果一个模块中既有在模块在端口声明时声明的参数，又有在模块实体中声明的参数，那这两种参数还能同时改写么？此时再用 defparam 改写参数 MASK 值时，编译报 Error。重点来了！！！如果你用带参数模块例化的方法去改写参数 MASK 的值，编译不会报错，MASK 也将被成功改写！

可能的解释为，在编译器看来，如果有模块在端口声明时的参数，那么实体中的参数将视为 localparam 类型，使用 defparam 将不能改写模块实体中声明的参数。

也可能和编译器有关系，大家也可以在其他编译器上实验。

(5)建议，对已有模块进行例化并将其相关参数进行改写时，不要采用 defparam 的方法。除了上述缺点外，defparam 一般也不可综合。

(6)而且建议，模块在编写时，如果预知将被例化且有需要改写的参数，都将这些参数写入到模块端口声明之前的地方(用关键字井号 # 表示)。这样的代码格式不仅有很好的可读性，而且方便调试。

## ZYNQ

ZYNQ 是 Xilinx 的片上系统(SoC)型 FPGA 产品，以异构计算架构集成了 FPGA 的可编程逻辑(PL)与 ARM 处理器核心(PS)，两者之间通过 AXI(Advanced eXtensible Interface)总线实现低延迟数据传输。PS 具有固定的架构，包含了处理器和系统的存储器，适合控制或具有串行执行特性的部分以及浮点计算等；而 PL 是完全灵活的，适合并行流处理。ZYNQ 的 PS 端为 ARM-Cortex A9 内核(应用级处理器，可运行 Linux)，PL 端为基于 Xilinx 7 系列的 FPGA 架构。

<img src="https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250619231520951.png" alt="" style="zoom: 80%;" />

ZYNQ 系列产品的命名规则：以 ZYNQ“XC7Z020-CLG400-2”为例，“XC”是“Xilinx 公司”；“7”是 7 系列(Series)；“Z”是型号是 zynq；“020”是价值索引(Value Index)，该数值越大对应芯片内部资源越丰富，价值越高；“clg400”芯片封装信息，“CLG”是芯片制造工艺信息，“400”是芯片封装引脚计数(Package Pin Count)；“-2”是速度等级(Speed Grade)；“-I”是温度等级(Temperature Grade)，温度等级有三种标准，分别是“C”、“E”与“I”。

## Vivado 使用

## HDL Bits

### Basic

可以在模块中间声明 wire 作为中介线(use as intermediate signals)

### Vector

Vectors must be declared as:

```verilog
type [upper:lower] vector_name;
```

```verilog
output reg [0:0] y;   // 1-bit reg that is also an output port (this is still a vector)
input wire [3:-2] z;  // 6-bit wire input (negative ranges are allowed)
output [3:0] a;       // 4-bit output wire. Type is 'wire' unless specified otherwise.
wire [0:7] b;         // 8-bit wire where b[0] is the most-significant bit.
```

In Verilog, once a vector is declared with a particular endianness, it must always be used the same way.Being consistent with endianness is good practice, as weird bugs occur if vectors of different endianness are assigned or used together.

```verilog
wire [2:0] a, c;   // Two vectors
assign a = 3'b101;  // a = 101
assign b = a;       // b =   1  implicitly-created wire
assign c = b;       // c = 001  <-- bug
my_module i1 (d,e); // d and e are implicitly one-bit wide if not declared.                    // This could be a bug if the port was intended to be a vector.
```

Adding ``default_nettype none` would make the third line of code an error, which makes the bug more visible.

```verilog
reg [7:0] mem [255:0];   // 256 unpacked elements, each of which is a 8-bit packed vector of reg.
```

takes the entire 4-bit vector _a_ and assigns it to the entire 8-bit vector _w_ (declarations are taken from above). If the lengths of the right and left sides don't match, it is zero-extended or truncated as appropriate.

```verilog
b[3:0]      // Illegal. Vector part-select must match the direction of the declaration.
b[0:3]      // The *upper* 4 bits of b.
```

Earlier, we mentioned that there are bitwise and logical versions of the various boolean operators. When using vectors, the distinction between the two operator types becomes important. A bitwise operation between two N-bit vectors replicates the operation for each bit of the vector and produces a N-bit output, while a logical operation treats the entire vector as a boolean value (true = non-zero, false = zero) and produces a 1-bit output.(|按位或，||逻辑或)

[Part selection](https://hdlbits.01xz.net/wiki/Vector1) was used to select portions of a vector. The concatenation operator `{a,b,c}` is used to create larger vectors by concatenating smaller portions of a vector together.Concatenation needs to know the width of every component (or how would you know the length of the result?). Thus, `{1, 2, 3}` is illegal and results in the error message: `unsized constants are not allowed in concatenations`.

```verilog
input [15:0] in;
output [23:0] out;
assign {out[7:0], out[15:8]} = in;         // Swap two bytes. Right side and left side are both 16-bit vectors.
assign out[15:0] = {in[7:0], in[15:8]};    // This is the same thing.
assign out = {in[7:0], in[15:8]};       // This is different. The 16-bit vector on the right is extended to
                                        // match the 24-bit vector on the left, so out[23:16] are zero.
                                        // In the first two examples, out[23:16] are not assigned.
```

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250620114416042.png)

```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
endmodule
```

This replicates _vector_ by _num_ times. _num_ must be a constant. Both sets of braces are required.

```verilog
{5{1'b1}}           // 5'b11111 (or 5'd31 or 5'h1f)
{2{a,b,c}}          // The same as {a,b,c,a,b,c}
{3'd5, {2{3'd6}}}   // 9'b101_110_110. It's a concatenation of 101 with
                    // the second vector, which is two copies of 3'b110.
```

One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending `4'b0101` (5) to 8 bits results in `8'b00000101` (5), while sign-extending `4'b1101` (-3) to 8 bits results in `8'b11111101` (-3).

{% raw %}

```verilog
module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = {{24{in[7]}}, in}; //注意加大括号
endmodule
```

{% endraw %}

### Module

The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written _inside_ another module's body (Code for different modules are not nested).

The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written _inside_ another module's body (Code for different modules are not nested).You may connect signals to the module by port name or port position.

When connecting modules, only the ports on the module are important. You do not need to know the code inside the module.

```verilog
module mod_a ( input in1, input in2, output out );
    // Module body
endmodule

module top_module ( input a, input b, output out );
    mod_a instance1(.in1(a), .in2(b), .out(out));
endmodule

// instantiation by position
module top_module (
    input a,
    input b,
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);

endmodule
```

声明好所有的模块和接线，用 assign 和.()来连接。

```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] o1, o2; // wire默认位宽是1，超过1记得要声明。
    wire cout1, cout2;
    add16 instance1(a[15:0], b[15:0], 1'b0, o1, cout1);
    add16 instance2(a[31:16], b[31:16], cout1, o2, cout2);
    assign sum = {o2, o1};

endmodule
```

由于数字电路是由与导线相连的逻辑门组成的，因此任何电路都可以表示为一些模块和赋值语句的组合。然而，有时这并不是描述电路最方便的方法。Procedures 为描述电路提供了一种可供选择的语法。

Combinational always blocks are equivalent to assign statements, thus there is always a way to express a combinational circuit both ways. The choice between which to use is mainly an issue of which syntax is more convenient. The syntax for code inside a procedural block is different from code that is outside. Procedural blocks have a richer set of statements (e.g., if-then, case), cannot contain continuous assignments\*, but also introduces many new non-intuitive ways of making errors. For example, the assign and combinational always block describe the same circuit. Both create the same blob of combinational logic. Both will recompute the output whenever any of the inputs (right side) changes value.

For combinational always blocks, always use a sensitivity list of `(*)`. Explicitly listing out the signals is error-prone (if you miss one), and is ignored for hardware synthesis. If you explicitly specify the sensitivity list and miss a signal, the synthesized hardware will still behave as though `(*)` was specified, but the simulation will not and not match the hardware's behaviour. (In SystemVerilog, use `always_comb`.)

A note on wire vs. reg: The left-hand-side of an assign statement must be a _net_ type (e.g., `wire`), while the left-hand-side of a procedural assignment (in an always block) must be a _variable_ type (e.g., `reg`). These types (wire vs. reg) have nothing to do with what hardware is synthesized, and is just syntax left over from Verilog's use as a hardware _simulation_ language.

assign 相当于一条连线，将表达式右边的电路直接通过 wire(线)连接到左边，左边信号必须是 wire 型。当右边变化了左边立马变化，方便用来描述简单的组合逻辑。

连续赋值语句是 Verilog 数据流建模的基本语句，用于对线网进行赋值，等价于门级描述，是从更高的抽象角度来对电路进行描述。连续赋值语句必须以关键词 assign 开始。

wire 只能被 assign 连续赋值，reg 只能在 initial 和 always 中赋值。

Blocking vs. Non-Blocking Assignment

There are three types of assignments in Verilog:

- Continuous assignments (`assign x = y;`). Can only be used when not inside a procedure ("always block").
- Procedural blocking assignment: (`x = y;`). Can only be used inside a procedure.
- Procedural non-blocking assignment: (`x <= y;`). Can only be used inside a procedure.

In a combinational always block, use blocking assignments. In a clocked always block, use non-blocking assignments.

语法正确的代码未必能生成合理的电路(组合逻辑 + 触发器)，核心原因是：未明确指定所有条件下的输出结果。在 Verilog 中，当代码未覆盖所有输入情况时，工具会默认 “保持输出不变”。这种 “保持状态” 的行为需要电路 “记住” 当前状态，而组合逻辑(如逻辑门)无法存储状态，因此会隐式生成锁存器(Latch)。锁存器属于时序逻辑元件，可能导致电路设计不符合预期(例如本应设计组合逻辑，却意外引入时序逻辑)。工具会给出警告(如 “Warning (10240): ... inferring latch (es)”)，除非锁存器是刻意设计的，否则通常意味着代码存在 bug。组合电路必须确保所有输出在所有输入条件下都有确定值，具体实现方式：必须使用 else 子句、为输出设置默认值

case 中记得写 default

if、case、while、for 都要放在 always 或 initial 块里

always @(\*)会综合出组合逻辑

always @(posedge clk)会综合出时序逻辑

1’b0 不是 1b'0

It may be less error-prone to explicitly specify the priority behaviour rather than rely on the ordering of the case items. For example, the following will still behave the same way if some of the case items were reordered, because any bit pattern can only match at most one case item:

To avoid creating latches, all outputs must be assigned a value in all possible conditions (See also [always_if2](https://hdlbits.01xz.net/wiki/always_if2)). Simply having a `default` case is not enough. You must assign a value to all four outputs in all four cases and the default case. This can involve a lot of unnecessary typing. One easy way around this is to assign a "default value" to the outputs _before_ the case statement.

The _reduction_ operators can do AND, OR, and XOR of the bits of a vector, producing one bit of output:

(归约运算符)

```verilog
& a[3:0]     // AND: a[3]&a[2]&a[1]&a[0]. Equivalent to (a[3:0] == 4'hf)
| b[3:0]     // OR:  b[3]|b[2]|b[1]|b[0]. Equivalent to (b[3:0] != 4'h0)
^ c[2:0]     // XOR: c[2]^c[1]^c[0]
```

These are _unary_ operators that have only one operand (similar to the NOT operators ! and ~). You can also invert the outputs of these to create NAND, NOR, and XNOR gates, e.g., `(~& d[7:0])`.

$bits() is a system function that returns the width of a signal.

- 产生根源：在 `always @(*)` 描述的组合逻辑块里，`out` 的赋值没有覆盖所有可能的情况。代码中通过三元运算符 `(in[i] == 1) ? (out + 1) : out;` 对 `out` 赋值，当 `in[i]` 为 `0` 时，`out` 保持原来的值 。但组合逻辑要求在所有输入变化场景下，输出都能被明确赋值，这种 “保持原值” 的行为会让综合工具推断出锁存器(因为需要存储 `out` 的前一状态 )。

当输出端口(如 `out`)被声明为 `wire`(默认)，但在 `always` 块中被赋值时，工具会自动将 `out` 视为 `reg` 类型。这是 Verilog 的隐式类型转换特性。

```verilog
module top_module(
    input [254:0] in,
    output [7:0] out );

    reg [7:0] temp; // always块中不能声明reg，另外注意是声明位宽为8的向量，不是长度为8的数组
    always @(*) begin
        temp = 8'd0;
        for (int i = 0; i < 255; i++) begin
            temp = (in[i] == 1) ? (temp + 8'd1) : temp;
        end
        // out = temp; // 也可以这样
    end
	assign out = temp;

endmodule
```

这里没有 latch 是因为每次进入 always 块都有块内初始化。这确保在任何输入组合下，`temp` 的初始值都是明确的。

==generate 语句==

真值表化简为 SOP 的形式

Verilog 里，`if`、`case`、`while`、`for` 都属于过程性语句(Procedural Statements)，它们的使命是描述 “在什么条件下，执行哪些操作”，必须依附于过程块(`always`/`initial`) 才能工作。

```verilog
module top_module (
	input [255:0] in,
	input [7:0] sel,
	output  out
);

	// Select one bit from vector in[]. The bit being selected can be variable.
	assign out = in[sel];

endmodule

```

example:

Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.(注意 overflow 的含义)

A _signed_ overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

```verilog
module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
);
    wire temp, flag1, flag2;
    assign s = a + b;
    assign flag1 = (a[$bits(a)-1] ^ b[$bits(b)-1] == 0);
    assign flag2 = (a[$bits(a)-1] ^ s[$bits(s)-1] == 1);
    assign overflow = (flag1 && flag2) ? 1'b1 : 1'b0;

endmodule

```

在 Verilog 中，assign {cout, sum} = a + b + cin; 之所以能正确工作，核心在于 Verilog 对操作数位宽的自动扩展与结果的合理拼接规则。

==BCD 加法器，是加完了转进制好，还是直接用十进制实现好？==

卡诺图化简，注意 abcd 谁是高位

### Sequential Logic

同步复位

```verilog
module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    always @(negedge clk) begin
        q <= (reset == 1'b0) ? d : 8'h34;
     end

endmodule
```

异步复位

```verilog
module top_module (
    input clk,
    input areset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk or posedge areset) begin
        q <= (areset == 1'b1) ? 1'b0 : d;
     end

endmodule
```

在 Verilog 中，同一个变量不能在多个 always 块中被赋值，这会导致多重驱动冲突。你的代码存在两个问题。

```verilog
module top_module (
    input clk,
    input in,
    output out);

    always @(posedge clk) begin
    	out <= in ^ out; // 用的是上一时刻的值
    end

endmodule
```

显式分离组合逻辑和时序逻辑使代码结构更清晰，当逻辑复杂时，便于理解信号流向和调试

FSM 示例

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250621134437072.png)

==任务相关的语法 $monitor==

case 后面不用 begin end 的块

时序逻辑中建议使用非阻塞赋值

在 Verilog 的时序逻辑中，信号的更新和采样都发生在时钟边沿(always 块中写的条件)

```verilog
module top_module(
	input clk,
	input [7:0] in,
	output reg [7:0] pedge);

	reg [7:0] d_last;

	always @(posedge clk) begin
		d_last <= in;			// Remember the state of the previous cycle
		pedge <= in & ~d_last;	// A positive edge occurred if input was 0 and is now 1.
	end

endmodule

```

## Dive Into FPGA

板载 USB 转 JTAG，不需要外置 JTAG 下载器

A9 的核

看看有没有 torch2.6 版本的 arm-torch

关注硬件的研究方向和优秀实验室

xc7z010clg400-1

vivido 操作和美化

verilog 语法和编程

Xilinx 7 系列的 CMT(clock management tile)包含一个 MMCM(multi-mode clock manager)和一个 PLL(phase-locked loop)

FPGA 中是 SRAM，断电数据丢失，上电之后加载 coe 文件可以假装 ROM

存储器：在给定时钟的情况下，将数据写入指定的地址

时钟上升沿写入数据，读出数据需要在下一个时钟上升沿才能读到

RAM 的输入信号包括 clk、addr、din、enable，输出为 dout

FIFO：先入先出，与 RAM 的区别是没有地址信号，地址是往上累加的

![image-20250829171723001](../assets/post-pics/image-20250829171723001.png)

![image-20250829171830964](../assets/post-pics/image-20250829171830964.png)

## Xilinx 视频笔记

Verilog 语法、FPGA 常见设计方法、状态机、线性序列机、常见的通讯驱动和接口设计

### 两选一多路器 Mux2 实践

run implementation：实现设计综合网表(布局布线)

run behavioral simulation：功能仿真

`timescale 1ns/1ns 两个 1ns 分别代表时间单位和时间精度

例化：将模块的端口和测试平台上的接线连接起来

#是仿真延时，不会生成对应的电路，主要是仿真的时候写激励用

tb：test_bench 测试平台

写好的是模块，需要例化，放在测试平台上，给激励信号观察输出结果

open syntehsized design 之后才可以看到 device 图，才可以进行引脚分配

reg 和 wire

RTL(寄存器传输级描述，即 Verilog 初版描述

### 三八译码器实现

```verilog
output reg [7:0] out; // 定义一个八位的、输出方向的、寄存器类型的数据
assign d = {a, 1'b0, b, c}; //{}进行位拼接，此处d为四位。1'b0中的b是描述多位宽信号的格式限定符，其它的还有o、d、h，分别为八、十、十六进制；进制在Verilog中可以混杂使用，各进制之间完全等效
always@(*)
```

以 always 块描述的信号赋值，被赋值对象必须定义为 reg

## 参考资料

[FPGA 和硬件加速](https://www.bilibili.com/video/BV1xo4y1c7AD/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468)

[Verilog 语法](https://www.runoob.com/w3cnote/Verilog-install.html)

[wire 和 reg 区别](https://www.cnblogs.com/SYoong/articles/5848601.html)

[几种赋值语句](https://fpga.eetrend.com/content/2019/100045217.html)

[ZYNQ Soc 介绍](https://fpga.eetrend.com/content/2022/100567012.html)
