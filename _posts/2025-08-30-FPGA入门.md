---
title: FPGA 入门
description: 知识储备
author: Hatrix
date: 2025-08-30 21:30:00 +0800
categories: [硬件开发]
tags: [实践技能]
math: true
mermaid: true
pin: false
image:
  path: https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20240424100647039.png
  alt: FPGA Basic
---

## FPGA 概览

FPGA 是 CLD(Configurable Logic Device，可编程逻辑设备)的一种，一般用于高质量低延迟的视频流处理，硬件加速等，其工作方式与 GPU 类似，将部分在 CPU 上由软件执行的工作 offload 到硬件电路上进行。

FPGA 的结构由可编程输入/输出单元、基本可编程逻辑单元、嵌入式块 RAM、布线资源和 IP 内核单元几部分组成。CLB(Configurable Logic Block，可配置逻辑块) 是 FPGA 的编程部分，也称逻辑单元，配置时可以只对芯片中的部分 CLB 编程，因此一块芯片可以同时执行不同的功能，或以流水线的形式在不同时刻对数据做不同的处理，故 FPGA 拥有很高的并行度。同样由于这一特性，FPGA 的设计目标之一，就是用最少的 CLB 实现需要的逻辑函数。

CLB 内部由查找表 LUT(Lookup Table)和触发器 FF(Flip-Flops)构成。LUT 是存储真值表的介质，也可用作分布式 RAM 作为快速高效的 on-chip memory。LUT 通过 SRAM 实现编程，可以反复编程且不用刷新电子。

<img src="https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250619231431328.png" alt="" style="zoom: 50%;" />

## 开发流程

FPGA 开发流程大致可以分为以下步骤：

- 设计(Design)：用 HDL 对硬件电路进行建模描述，需要定义电路功能实现、设计约束和测试用例。对于许多常用的功能，有现成的 IP 核作为轮子可以直接使用。测试用例是针对功能仿真的，由.sim 文件管理；设计约束主要由.xdc 文件管理。
- 功能仿真(Simulation)：又称前仿真，指在计算机的仿真器上运行 Verilog 代码，在不考虑硬件电路实现和绝大部分约束的情况下，仅验证逻辑功能是否正确。功能仿真是可选步骤。
- 分析和综合(Systhesis)：检查 HDL 代码是否符合综合规则，并由 EDA 在厂家提供的标准单元库和设计阶段中的约束下，编译出由 HDL 描述的逻辑网表并进行逻辑优化。逻辑网表是指一个标准的逻辑门或查找表的集合，是一个逻辑层面的结构，可以包括时序触发器、寄存器等时序元素，是逻辑门级别的描述。另外，注意不是所有的 HDL 语句都可以综合出相应的逻辑电路。
- 布局布线(Implementation)：分配引脚并确定内部电路的连接关系，进行 layout 和 IO planning，根据设计阶段的约束文件和综合出的逻辑网表，利用厂家提供的标准元件库对门级电路进行布局，在考虑各种约束和优化的情况下，将设计中的门级网表映射到 FPGA 的物理布局上并进行物理优化。完成这一步后就将 HDL 描述的模型电路转化为标准元件库组成的数字电路，且此时的电路已经包含了时延信息。
- 时序分析(Analysis)：指时序仿真，又称后仿真，用于检查信号延迟是否满足要求。时序分析有静态时序分析(STA)和动态时序分析(DTA)，静态时序分析是通过计算每条路径的延迟来检查是否满足设计的时序约束；动态时序分析是模拟设计的运行，动态检查信号的传播延迟，用于验证时序边界。时序分析是可选步骤。
- 生成比特流和板级调试(Bitstream)：生成烧录到板子中的二进制文件.bit，并进行实际硬件的调试。生成比特流之前需要完成设计、综合和布局布线。比特流文件是一种专门为 FPGA 硬件配置而设计的格式，文件内容是经过优化的、以二进制形式存储的配置信息，包含了逻辑元件的映射、时序约束、硬件资源配置等所有信息，能够直接在 FPGA 上加载和执行。

设计约束包括：

- 引脚约束：又称 IO 约束、引脚绑定，将逻辑信号与物理引脚进行对应
- 时序约束：保证各信号按预期的时序顺序传输，在规定时间内到达正确的位置，主要类型包括时钟约束、输入输出延迟约束、时序路径约束等
- 资源约束：又称面积约束，限制 FPGA 资源的使用量来适配目标 FPGA 的可用资源
- 布局约束：用于控制设计中各逻辑单元的物理布局，确保逻辑单元被放置到 FPGA 的指定资源区域内，从而提高时序性能、减少信号延迟并优化资源使用

## ZYNQ

FPGA 和 SoC 是 Xilinx 的两大主要产品系列。

FPGA 即纯 FPGA 芯片，按照工艺节点分为 UltraScale+(16nm)、UltraScale(20nm)、7 Series(28nm)三大类，类似于 CPU 中第几代的概念。在每个类别中，又分为 Spartan、Artex、Kintex、Virtex 四个子系列，面向不同的应用场景和市场定位，性能依次提升。

除了最新的 Versal ACAP(Adaptive Compute Acceleration Platform，自适应计算加速平台)之外，Xilinx 将 SoC 系列命名为 ZYNQ 计算架构，是 FPGA + Arm 的多处理器系统，集成了 FPGA 的可编程逻辑(PL)与 ARM 处理器核心(PS)，两者之间通过 AXI(Advanced eXtensible Interface)总线实现低延迟数据传输。PS 具有固定的架构，包含了处理器和系统的存储器，适合控制或具有串行执行特性的部分以及浮点计算等；而 PL 是完全灵活的，适合并行流处理。

ZYNQ 架构分为 ZYNQ-7000 SoC、ZYNQ UltraScale+ MPSoC、ZYNQ UltraScale+ RFSoC 三类。ZYNQ-7000 SoC 的 PS 端为 Cortex A9 的 Arm 核心，为 ARMv7-A 架构，32 位；PL 端为 7 Series 的 FPGA。ZYNQ UltraScale+ MPSoC(MultiProcessor)的 PS 端为 Cortex A53 的 Arm 核心，为 ARM-v8-A 架构，64 位，另外还配备 Cortex-R5F 作为协处理器；PL 端为 UltraScale+的 FPGA。ZYNQ UltraScale+ MPSoC 再往下又可以细分为 CG、EG、EV 三类，面向的硬冲场景不同。ZYNQ UltraScale+ RFSoC(Radio Frequency)与 ZYNQ UltraScale+ MPSoC 的区别仅在于配备了高速 ADC 和 DAC 通道，用于射频领域。

## Vivado 使用

## HDL Bits

### Basic

可以在模块中间声明 wire 作为中介线(use as intermediate signals)

### Vector

Vectors must be declared as:

```verilog
type [upper:lower] vector_name;
```

```verilog
output reg [0:0] y;   // 1-bit reg that is also an output port (this is still a vector)
input wire [3:-2] z;  // 6-bit wire input (negative ranges are allowed)
output [3:0] a;       // 4-bit output wire. Type is 'wire' unless specified otherwise.
wire [0:7] b;         // 8-bit wire where b[0] is the most-significant bit.
```

In Verilog, once a vector is declared with a particular endianness, it must always be used the same way.Being consistent with endianness is good practice, as weird bugs occur if vectors of different endianness are assigned or used together.

```verilog
wire [2:0] a, c;   // Two vectors
assign a = 3'b101;  // a = 101
assign b = a;       // b =   1  implicitly-created wire
assign c = b;       // c = 001  <-- bug
my_module i1 (d,e); // d and e are implicitly one-bit wide if not declared.                    // This could be a bug if the port was intended to be a vector.
```

Adding ``default_nettype none` would make the third line of code an error, which makes the bug more visible.

```verilog
reg [7:0] mem [255:0];   // 256 unpacked elements, each of which is a 8-bit packed vector of reg.
```

takes the entire 4-bit vector _a_ and assigns it to the entire 8-bit vector _w_ (declarations are taken from above). If the lengths of the right and left sides don't match, it is zero-extended or truncated as appropriate.

```verilog
b[3:0]      // Illegal. Vector part-select must match the direction of the declaration.
b[0:3]      // The *upper* 4 bits of b.
```

Earlier, we mentioned that there are bitwise and logical versions of the various boolean operators. When using vectors, the distinction between the two operator types becomes important. A bitwise operation between two N-bit vectors replicates the operation for each bit of the vector and produces a N-bit output, while a logical operation treats the entire vector as a boolean value (true = non-zero, false = zero) and produces a 1-bit output.(|按位或，||逻辑或)

[Part selection](https://hdlbits.01xz.net/wiki/Vector1) was used to select portions of a vector. The concatenation operator `{a,b,c}` is used to create larger vectors by concatenating smaller portions of a vector together.Concatenation needs to know the width of every component (or how would you know the length of the result?). Thus, `{1, 2, 3}` is illegal and results in the error message: `unsized constants are not allowed in concatenations`.

```verilog
input [15:0] in;
output [23:0] out;
assign {out[7:0], out[15:8]} = in;         // Swap two bytes. Right side and left side are both 16-bit vectors.
assign out[15:0] = {in[7:0], in[15:8]};    // This is the same thing.
assign out = {in[7:0], in[15:8]};       // This is different. The 16-bit vector on the right is extended to
                                        // match the 24-bit vector on the left, so out[23:16] are zero.
                                        // In the first two examples, out[23:16] are not assigned.
```

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250620114416042.png)

```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
endmodule
```

This replicates _vector_ by _num_ times. _num_ must be a constant. Both sets of braces are required.

```verilog
{5{1'b1}}           // 5'b11111 (or 5'd31 or 5'h1f)
{2{a,b,c}}          // The same as {a,b,c,a,b,c}
{3'd5, {2{3'd6}}}   // 9'b101_110_110. It's a concatenation of 101 with
                    // the second vector, which is two copies of 3'b110.
```

One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending `4'b0101` (5) to 8 bits results in `8'b00000101` (5), while sign-extending `4'b1101` (-3) to 8 bits results in `8'b11111101` (-3).

{% raw %}

```verilog
module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = {{24{in[7]}}, in}; //注意加大括号
endmodule
```

{% endraw %}

### Module

The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written _inside_ another module's body (Code for different modules are not nested).

The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written _inside_ another module's body (Code for different modules are not nested).You may connect signals to the module by port name or port position.

When connecting modules, only the ports on the module are important. You do not need to know the code inside the module.

```verilog
module mod_a ( input in1, input in2, output out );
    // Module body
endmodule

module top_module ( input a, input b, output out );
    mod_a instance1(.in1(a), .in2(b), .out(out));
endmodule

// instantiation by position
module top_module (
    input a,
    input b,
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);

endmodule
```

声明好所有的模块和接线，用 assign 和.()来连接。

```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] o1, o2; // wire默认位宽是1，超过1记得要声明。
    wire cout1, cout2;
    add16 instance1(a[15:0], b[15:0], 1'b0, o1, cout1);
    add16 instance2(a[31:16], b[31:16], cout1, o2, cout2);
    assign sum = {o2, o1};

endmodule
```

由于数字电路是由与导线相连的逻辑门组成的，因此任何电路都可以表示为一些模块和赋值语句的组合。然而，有时这并不是描述电路最方便的方法。Procedures 为描述电路提供了一种可供选择的语法。

Combinational always blocks are equivalent to assign statements, thus there is always a way to express a combinational circuit both ways. The choice between which to use is mainly an issue of which syntax is more convenient. The syntax for code inside a procedural block is different from code that is outside. Procedural blocks have a richer set of statements (e.g., if-then, case), cannot contain continuous assignments\*, but also introduces many new non-intuitive ways of making errors. For example, the assign and combinational always block describe the same circuit. Both create the same blob of combinational logic. Both will recompute the output whenever any of the inputs (right side) changes value.

For combinational always blocks, always use a sensitivity list of `(*)`. Explicitly listing out the signals is error-prone (if you miss one), and is ignored for hardware synthesis. If you explicitly specify the sensitivity list and miss a signal, the synthesized hardware will still behave as though `(*)` was specified, but the simulation will not and not match the hardware's behaviour. (In SystemVerilog, use `always_comb`.)

A note on wire vs. reg: The left-hand-side of an assign statement must be a _net_ type (e.g., `wire`), while the left-hand-side of a procedural assignment (in an always block) must be a _variable_ type (e.g., `reg`). These types (wire vs. reg) have nothing to do with what hardware is synthesized, and is just syntax left over from Verilog's use as a hardware _simulation_ language.

assign 相当于一条连线，将表达式右边的电路直接通过 wire(线)连接到左边，左边信号必须是 wire 型。当右边变化了左边立马变化，方便用来描述简单的组合逻辑。

连续赋值语句是 Verilog 数据流建模的基本语句，用于对线网进行赋值，等价于门级描述，是从更高的抽象角度来对电路进行描述。连续赋值语句必须以关键词 assign 开始。

wire 只能被 assign 连续赋值，reg 只能在 initial 和 always 中赋值。

Blocking vs. Non-Blocking Assignment

There are three types of assignments in Verilog:

- Continuous assignments (`assign x = y;`). Can only be used when not inside a procedure ("always block").
- Procedural blocking assignment: (`x = y;`). Can only be used inside a procedure.
- Procedural non-blocking assignment: (`x <= y;`). Can only be used inside a procedure.

In a combinational always block, use blocking assignments. In a clocked always block, use non-blocking assignments.

语法正确的代码未必能生成合理的电路(组合逻辑 + 触发器)，核心原因是：未明确指定所有条件下的输出结果。在 Verilog 中，当代码未覆盖所有输入情况时，工具会默认 “保持输出不变”。这种 “保持状态” 的行为需要电路 “记住” 当前状态，而组合逻辑(如逻辑门)无法存储状态，因此会隐式生成锁存器(Latch)。锁存器属于时序逻辑元件，可能导致电路设计不符合预期(例如本应设计组合逻辑，却意外引入时序逻辑)。工具会给出警告(如 “Warning (10240): ... inferring latch (es)”)，除非锁存器是刻意设计的，否则通常意味着代码存在 bug。组合电路必须确保所有输出在所有输入条件下都有确定值，具体实现方式：必须使用 else 子句、为输出设置默认值

case 中记得写 default

if、case、while、for 都要放在 always 或 initial 块里

always @(\*)会综合出组合逻辑

always @(posedge clk)会综合出时序逻辑

1’b0 不是 1b'0

It may be less error-prone to explicitly specify the priority behaviour rather than rely on the ordering of the case items. For example, the following will still behave the same way if some of the case items were reordered, because any bit pattern can only match at most one case item:

To avoid creating latches, all outputs must be assigned a value in all possible conditions (See also [always_if2](https://hdlbits.01xz.net/wiki/always_if2)). Simply having a `default` case is not enough. You must assign a value to all four outputs in all four cases and the default case. This can involve a lot of unnecessary typing. One easy way around this is to assign a "default value" to the outputs _before_ the case statement.

The _reduction_ operators can do AND, OR, and XOR of the bits of a vector, producing one bit of output:

(归约运算符)

```verilog
& a[3:0]     // AND: a[3]&a[2]&a[1]&a[0]. Equivalent to (a[3:0] == 4'hf)
| b[3:0]     // OR:  b[3]|b[2]|b[1]|b[0]. Equivalent to (b[3:0] != 4'h0)
^ c[2:0]     // XOR: c[2]^c[1]^c[0]
```

These are _unary_ operators that have only one operand (similar to the NOT operators ! and ~). You can also invert the outputs of these to create NAND, NOR, and XNOR gates, e.g., `(~& d[7:0])`.

$bits() is a system function that returns the width of a signal.

- 产生根源：在 `always @(*)` 描述的组合逻辑块里，`out` 的赋值没有覆盖所有可能的情况。代码中通过三元运算符 `(in[i] == 1) ? (out + 1) : out;` 对 `out` 赋值，当 `in[i]` 为 `0` 时，`out` 保持原来的值 。但组合逻辑要求在所有输入变化场景下，输出都能被明确赋值，这种 “保持原值” 的行为会让综合工具推断出锁存器(因为需要存储 `out` 的前一状态 )。

当输出端口(如 `out`)被声明为 `wire`(默认)，但在 `always` 块中被赋值时，工具会自动将 `out` 视为 `reg` 类型。这是 Verilog 的隐式类型转换特性。

```verilog
module top_module(
    input [254:0] in,
    output [7:0] out );

    reg [7:0] temp; // always块中不能声明reg，另外注意是声明位宽为8的向量，不是长度为8的数组
    always @(*) begin
        temp = 8'd0;
        for (int i = 0; i < 255; i++) begin
            temp = (in[i] == 1) ? (temp + 8'd1) : temp;
        end
        // out = temp; // 也可以这样
    end
	assign out = temp;

endmodule
```

这里没有 latch 是因为每次进入 always 块都有块内初始化。这确保在任何输入组合下，`temp` 的初始值都是明确的。

==generate 语句==

真值表化简为 SOP 的形式

Verilog 里，`if`、`case`、`while`、`for` 都属于过程性语句(Procedural Statements)，它们的使命是描述 “在什么条件下，执行哪些操作”，必须依附于过程块(`always`/`initial`) 才能工作。

```verilog
module top_module (
	input [255:0] in,
	input [7:0] sel,
	output  out
);

	// Select one bit from vector in[]. The bit being selected can be variable.
	assign out = in[sel];

endmodule

```

example:

Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.(注意 overflow 的含义)

A _signed_ overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

```verilog
module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
);
    wire temp, flag1, flag2;
    assign s = a + b;
    assign flag1 = (a[$bits(a)-1] ^ b[$bits(b)-1] == 0);
    assign flag2 = (a[$bits(a)-1] ^ s[$bits(s)-1] == 1);
    assign overflow = (flag1 && flag2) ? 1'b1 : 1'b0;

endmodule

```

在 Verilog 中，assign {cout, sum} = a + b + cin; 之所以能正确工作，核心在于 Verilog 对操作数位宽的自动扩展与结果的合理拼接规则。

==BCD 加法器，是加完了转进制好，还是直接用十进制实现好？==

卡诺图化简，注意 abcd 谁是高位

### Sequential Logic

同步复位

```verilog
module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    always @(negedge clk) begin
        q <= (reset == 1'b0) ? d : 8'h34;
     end

endmodule
```

异步复位

```verilog
module top_module (
    input clk,
    input areset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk or posedge areset) begin
        q <= (areset == 1'b1) ? 1'b0 : d;
     end

endmodule
```

在 Verilog 中，同一个变量不能在多个 always 块中被赋值，这会导致多重驱动冲突。你的代码存在两个问题。

```verilog
module top_module (
    input clk,
    input in,
    output out);

    always @(posedge clk) begin
    	out <= in ^ out; // 用的是上一时刻的值
    end

endmodule
```

显式分离组合逻辑和时序逻辑使代码结构更清晰，当逻辑复杂时，便于理解信号流向和调试

FSM 示例

![](https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250621134437072.png)

==任务相关的语法 $monitor==

case 后面不用 begin end 的块

时序逻辑中建议使用非阻塞赋值

在 Verilog 的时序逻辑中，信号的更新和采样都发生在时钟边沿(always 块中写的条件)

```verilog
module top_module(
	input clk,
	input [7:0] in,
	output reg [7:0] pedge);

	reg [7:0] d_last;

	always @(posedge clk) begin
		d_last <= in;			// Remember the state of the previous cycle
		pedge <= in & ~d_last;	// A positive edge occurred if input was 0 and is now 1.
	end

endmodule
```

十进制计数器测试

```verilog
`timescale 1ns/1ns

module test ;
    reg          rstn ;
    reg          clk ;
    reg [3:0]    cnt ;
    wire         cout ;

    counter10     u_counter (
        .rstn    (rstn),
        .clk     (clk),
        .cnt     (cnt),
        .cout    (cout));

    initial begin
        clk       = 0 ;
        rstn      = 0 ;
        #10 ;
        rstn      = 1'b1 ;
        wait (test.u_counter.cnt_temp == 4'd4) ;
        @(negedge clk) ;
        force     test.u_counter.cnt_temp = 4'd6 ;
        force     test.u_counter.cout     = 1'b1 ;
        #40 ;
        @(negedge clk) ;
        release   test.u_counter.cnt_temp ;
        release   test.u_counter.cout ;
    end

    initial begin
        clk = 0 ;
        forever #10 clk = ~ clk ;
    end

    //finish the simulation
    always begin
        #1000;
        if ($time >= 1000) $finish ;
    end

endmodule // test
```

## Dive Into FPGA

板载 USB 转 JTAG，不需要外置 JTAG 下载器

A9 的核

看看有没有 torch2.6 版本的 arm-torch

关注硬件的研究方向和优秀实验室

xc7z010clg400-1

vivido 操作和美化

verilog 语法和编程

Xilinx 7 系列的 CMT(clock management tile)包含一个 MMCM(multi-mode clock manager)和一个 PLL(phase-locked loop)

FPGA 中是 SRAM，断电数据丢失，上电之后加载 coe 文件可以假装 ROM

存储器：在给定时钟的情况下，将数据写入指定的地址

时钟上升沿写入数据，读出数据需要在下一个时钟上升沿才能读到

RAM 的输入信号包括 clk、addr、din、enable，输出为 dout

FIFO：先入先出，与 RAM 的区别是没有地址信号，地址是往上累加的

![image-20250829171723001](../assets/post-pics/image-20250829171723001.png)

![image-20250829171830964](../assets/post-pics/image-20250829171830964.png)

因 PS 端编译报错而移除的环境变量

C:\WINDOWS\System32\OpenSSH\

D:\ToolChain\msys2\ucrt64\bin

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\Common7\IDE\CommonExtensions\Microsoft\TeamFoundation\Team Explorer\Git\usr\bin

## Xilinx 视频笔记

Verilog 语法、FPGA 常见设计方法、状态机、线性序列机、常见的通讯驱动和接口设计

### 两选一多路器 Mux2 实践

run implementation：实现设计综合网表(布局布线)

run behavioral simulation：功能仿真

`timescale 1ns/1ns 两个 1ns 分别代表时间单位和时间精度

例化：将模块的端口和测试平台上的接线连接起来

#是仿真延时，不会生成对应的电路，主要是仿真的时候写激励用

tb：test_bench 测试平台

写好的是模块，需要例化，放在测试平台上，给激励信号观察输出结果

open syntehsized design 之后才可以看到 device 图，才可以进行引脚分配

reg 和 wire

RTL(寄存器传输级描述，即 Verilog 初版描述

### 三八译码器实现

```verilog
output reg [7:0] out; // 定义一个八位的、输出方向的、寄存器类型的数据
assign d = {a, 1'b0, b, c}; //{}进行位拼接，此处d为四位。1'b0中的b是描述多位宽信号的格式限定符，其它的还有o、d、h，分别为八、十、十六进制；进制在Verilog中可以混杂使用，各进制之间完全等效
always@(*)
```

以 always 块描述的信号赋值，被赋值对象必须定义为 reg

## 参考资料

[FPGA 和硬件加速](https://www.bilibili.com/video/BV1xo4y1c7AD/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468)

[ZYNQ Soc 介绍](https://fpga.eetrend.com/content/2022/100567012.html)
