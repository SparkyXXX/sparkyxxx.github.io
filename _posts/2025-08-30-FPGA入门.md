---
title: FPGA 入门
description: 知识储备
author: Hatrix
date: 2025-08-30 21:30:00 +0800
categories: [硬件开发]
tags: [实践技能]
math: true
mermaid: true
pin: false
image:
  path: https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20240424100647039.png
  alt: FPGA Basic
---

## FPGA 概览

FPGA 是 CLD(Configurable Logic Device，可编程逻辑设备)的一种，一般用于高质量低延迟的视频流处理，硬件加速等，其工作方式与 GPU 类似，将部分在 CPU 上由软件执行的工作 offload 到硬件电路上进行。

FPGA 的结构由可编程输入/输出单元、基本可编程逻辑单元、嵌入式块 RAM、布线资源和 IP 内核单元几部分组成。CLB(Configurable Logic Block，可配置逻辑块) 是 FPGA 的编程部分，也称逻辑单元，配置时可以只对芯片中的部分 CLB 编程，因此一块芯片可以同时执行不同的功能，或以流水线的形式在不同时刻对数据做不同的处理，故 FPGA 拥有很高的并行度。同样由于这一特性，FPGA 的设计目标之一，就是用最少的 CLB 实现需要的逻辑函数。

CLB 内部由查找表 LUT(Lookup Table)和触发器 FF(Flip-Flops)构成。LUT 是存储真值表的介质，也可用作分布式 RAM 作为快速高效的 on-chip memory。LUT 通过 SRAM 实现编程，可以反复编程且不用刷新电子。

<img src="https://cdn.jsdelivr.net/gh/SparkyXXX/Hatrix-s-Blog-Image/img/20250619231431328.png" alt="" style="zoom: 50%;" />

## 开发流程

FPGA 开发流程大致可以分为以下步骤：

- 设计(Design)：用 HDL 对硬件电路进行建模描述，需要定义电路功能实现、设计约束和测试用例。对于许多常用的功能，有现成的 IP 核作为轮子可以直接使用。测试用例是针对功能仿真的，由.sim 文件管理；设计约束主要由.xdc 文件管理。
- 功能仿真(Simulation)：又称前仿真，指在计算机的仿真器上运行 Verilog 代码，在不考虑硬件电路实现和绝大部分约束的情况下，仅验证逻辑功能是否正确。功能仿真是可选步骤。
- 分析和综合(Systhesis)：检查 HDL 代码是否符合综合规则，并由 EDA 在厂家提供的标准单元库和设计阶段中的约束下，编译出由 HDL 描述的逻辑网表并进行逻辑优化。逻辑网表是指一个标准的逻辑门或查找表的集合，是一个逻辑层面的结构，可以包括时序触发器、寄存器等时序元素，是逻辑门级别的描述。另外，注意不是所有的 HDL 语句都可以综合出相应的逻辑电路。
- 布局布线(Implementation)：分配引脚并确定内部电路的连接关系，进行 layout 和 IO planning，根据设计阶段的约束文件和综合出的逻辑网表，利用厂家提供的标准元件库对门级电路进行布局，在考虑各种约束和优化的情况下，将设计中的门级网表映射到 FPGA 的物理布局上并进行物理优化。完成这一步后就将 HDL 描述的模型电路转化为标准元件库组成的数字电路，且此时的电路已经包含了时延信息。
- 时序分析(Analysis)：指时序仿真，又称后仿真，用于检查信号延迟是否满足要求。时序分析有静态时序分析(STA)和动态时序分析(DTA)，静态时序分析是通过计算每条路径的延迟来检查是否满足设计的时序约束；动态时序分析是模拟设计的运行，动态检查信号的传播延迟，用于验证时序边界。时序分析是可选步骤。
- 生成比特流和板级调试(Bitstream)：生成烧录到板子中的二进制文件.bit，并进行实际硬件的调试。生成比特流之前需要完成设计、综合和布局布线。比特流文件是一种专门为 FPGA 硬件配置而设计的格式，文件内容是经过优化的、以二进制形式存储的配置信息，包含了逻辑元件的映射、时序约束、硬件资源配置等所有信息，能够直接在 FPGA 上加载和执行。

设计约束包括：

- 引脚约束：又称 IO 约束、引脚绑定，将逻辑信号与物理引脚进行对应
- 时序约束：保证各信号按预期的时序顺序传输，在规定时间内到达正确的位置，主要类型包括时钟约束、输入输出延迟约束、时序路径约束等
- 资源约束：又称面积约束，限制 FPGA 资源的使用量来适配目标 FPGA 的可用资源
- 布局约束：用于控制设计中各逻辑单元的物理布局，确保逻辑单元被放置到 FPGA 的指定资源区域内，从而提高时序性能、减少信号延迟并优化资源使用

## Verilog 最佳实践

1. 对于时序逻辑和组合逻辑的综合电路，建议分开把组合逻辑部分和时序逻辑部分分开写，遵循组合逻辑用阻塞赋值，时序逻辑用非阻塞赋值的原则。若组合逻辑部分也用非阻塞，会出现因并行导致时序逻辑用的是上一时刻的值（组合逻辑还没更新完，时序逻辑就并行执行了）。而阻塞赋值有`always`块中对`reg`赋值，以及`assign`中直接对`wire`赋值两种；具体使用根据变量类型以及要描述的组合逻辑的复杂程度决定。
2. `always`块有两种用法：`always @ (*)`用于对组合逻辑建模，输出对所有输入敏感，这种`always`块用阻塞赋值；`always @ (posedge/negedge xxx)`用于对时序逻辑建模，只在时钟上升/下降沿更新输出，这种`always`块用非阻塞赋值。`assign`同样是用于组合逻辑的，可以看作是`always @ (*)`的简便用法，`always @ (*)`块相较于`assign`可以表达更复杂的组合逻辑。
3. 不指定位宽时，默认为 32 位的位宽，建议显式指定位宽。另外为了方便表示，建议都使用十进制 d 而不用二进制 b 或其它进制表示数值。
4. 模块连线时，对于悬空无连接的端口，建议显式`.xxx()`来表示悬空，而不要不写这个端口。

## Verilog 电路实现

1. 模块内部可以声明 wire 作为中间变量来表示中间结果。
2. `always @ (*)`和`case`构成 mux
3. 状态机分 Moore 和 Mealy 两类：Moore 状态机的输出只与当前状态有关而与当前输入无关，即输入与输出隔离；Mealy 状态机的输出与当前状态和当前输入都有关，输入变化输出立即变化，响应比 Moore 状态机快一个时钟周期。一般使用三段式状态机，三个步骤分别为：传递寄存器状态（时序逻辑、非阻塞）；根据当前状态确定下一个状态（组合逻辑、阻塞）；由状态确定输出（组合逻辑、阻塞）。另外，可以分别用状态方程和输出方程代替状态机的后两个步骤中冗长的 case 写法。

合理拼接、自动扩展、模块连线

组合逻辑：基本门电路、多路选择器、加法器、卡诺图

时序逻辑：触发器、锁存器、计数器、移位寄存器、元胞自动机、有限状态机

### 判断溢出

```verilog
module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
);
    wire temp, flag1, flag2;
    assign s = a + b;
    // $bits()是获得变量位宽的语法糖
    assign flag1 = (a[$bits(a)-1] ^ b[$bits(b)-1] == 0);
    assign flag2 = (a[$bits(a)-1] ^ s[$bits(s)-1] == 1);
    assign overflow = (flag1 && flag2) ? 1'b1 : 1'b0;

endmodule
```

### 同步复位和异步复位

```verilog
// 同步复位
module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    always @(negedge clk) begin
        q <= (reset == 1'b0) ? d : 8'h34;
     end

endmodule

//异步复位
module top_module (
    input clk,
    input areset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk or posedge areset) begin
        q <= (areset == 1'b1) ? 1'b0 : d;
     end

endmodule
```

### 移位寄存器变种

对于多位的移位寄存器变种，既可以写单个位的子模块然后连线，也可以直接将时序逻辑和组合逻辑分开直接多位写

```verilog
// 第一种写法
module top_module (
    input clk,
    input x,
    output z
);
    wire d0, d1, d2, q0, q1, q2;
    assign d0 = x ^ q0;
    assign d1 = x & ~q1;
    assign d2 = x | ~q2;
    assign z = ~(q0 | q1 | q2);
    ff ins0 (clk, d0, q0);
    ff ins1 (clk, d1, q1);
    ff ins2 (clk, d2, q2);

endmodule

module ff(input clk, input d, output q);
    always @(posedge clk) begin
    	q <= d;
    end
endmodule

// 第二种写法
module top_module (
    input clk,
    input x,
    output z
);
    wire q0, q1, q2;
    always @ (posedge clk) begin
    	q0 <= q0 ^ x;
    end
    always @ (posedge clk) begin
        q1 <= (~q1) & x;
    end
    always @ (posedge clk) begin
        q2 <= (~q2) | x;
    end
    assign z = ~(q0 | q1 | q2);

endmodule
```

### 四位 BCD 计数器

```verilog
module top_module (
    input clk,
    input reset,
    output [3:1] ena,
    output [15:0] q);

    bcd_counter ins0(.clk(clk), .reset(reset), .enable(1'b1), .co(ena[1]), .q_reg(q[3:0]));
    bcd_counter ins1(.clk(clk), .reset(reset), .enable(ena[1]), .co(ena[2]), .q_reg(q[7:4]));
    bcd_counter ins2(.clk(clk), .reset(reset), .enable(ena[2]), .co(ena[3]), .q_reg(q[11:8]));
    bcd_counter ins3(.clk(clk), .reset(reset), .enable(ena[3]), .co(), .q_reg(q[15:12]));

endmodule

module bcd_counter (
    input clk,
    input reset,
    input enable,
    output co,
    output reg [3:0] q_reg);

    always @ (posedge clk) begin
        if (reset == 1'b1) begin
        	q_reg <= 4'd0;
        end
        else begin
            if (enable == 1'b1) begin
            	if (q_reg == 4'd9) begin
            	q_reg <= 4'd0;
                end
                else begin
                    q_reg <= q_reg + 4'd1;
                end
            end
        end
    end
    assign co = (enable && (q_reg == 4'd9));

endmodule
```

### mealy 状态机

```verilog
// vending-machine
// 2 yuan for a bottle of drink
// only 2 coins supported: 5 jiao and 1 yuan
// finish the function of selling and changing

module  vending_machine_mealy  (
    input           clk ,
    input           rstn ,
    input [1:0]     coin ,     //01 for 0.5 jiao, 10 for 1 yuan

    output [1:0]    change ,
    output          sell    //output the drink
    );

    //machine state decode
    parameter            IDLE   = 3'd0 ;
    parameter            GET05  = 3'd1 ;
    parameter            GET10  = 3'd2 ;
    parameter            GET15  = 3'd3 ;

    //machine variable
    reg [2:0]            st_next ;
    reg [2:0]            st_cur ;

    //(1) state transfer
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            st_cur      <= 'b0 ;
        end
        else begin
            st_cur      <= st_next ;
        end
    end

    //(2) state switch, using block assignment for combination-logic
    //all case items need to be displayed completely
    always @(*) begin
        //st_next = st_cur ;//如果条件选项考虑不全，可以赋初值消除latch
        case(st_cur)
            IDLE:
                case (coin)
                    2'b01:     st_next = GET05 ;
                    2'b10:     st_next = GET10 ;
                    default:   st_next = IDLE ;
                endcase
            GET05:
                case (coin)
                    2'b01:     st_next = GET10 ;
                    2'b10:     st_next = GET15 ;
                    default:   st_next = GET05 ;
                endcase

            GET10:
                case (coin)
                    2'b01:     st_next = GET15 ;
                    2'b10:     st_next = IDLE ;
                    default:   st_next = GET10 ;
                endcase
            GET15:
                case (coin)
                    2'b01,2'b10:
                               st_next = IDLE ;
                    default:   st_next = GET15 ;
                endcase
            default:    st_next = IDLE ;
        endcase
    end

    //(3) output logic, using non-block assignment
    reg  [1:0]   change_r ;
    reg          sell_r ;
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            change_r       <= 2'b0 ;
            sell_r         <= 1'b0 ;
        end
        else if ((st_cur == GET15 && coin ==2'h1)
               || (st_cur == GET10 && coin ==2'd2)) begin
            change_r       <= 2'b0 ;
            sell_r         <= 1'b1 ;
        end
        else if (st_cur == GET15 && coin == 2'h2) begin
            change_r       <= 2'b1 ;
            sell_r         <= 1'b1 ;
        end
        else begin
            change_r       <= 2'b0 ;
            sell_r         <= 1'b0 ;
        end
    end
    assign       sell    = sell_r ;
    assign       change  = change_r ;

endmodule
```

### moore 状态机

```verilog
module  vending_machine_moore    (
    input           clk ,
    input           rstn ,
    input [1:0]     coin ,     //01 for 0.5 jiao, 10 for 1 yuan

    output [1:0]    change ,
    output          sell    //output the drink
    );

    //machine state decode
    parameter            IDLE   = 3'd0 ;
    parameter            GET05  = 3'd1 ;
    parameter            GET10  = 3'd2 ;
    parameter            GET15  = 3'd3 ;
    // new state for moore state-machine
    parameter            GET20  = 3'd4 ;
    parameter            GET25  = 3'd5 ;

    //machine variable
    reg [2:0]            st_next ;
    reg [2:0]            st_cur ;

    //(1) state transfer
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            st_cur      <= 'b0 ;
        end
        else begin
            st_cur      <= st_next ;
        end
    end

    //(2) state switch, using block assignment for combination-logic
    always @(*) begin //all case items need to be displayed completely
        case(st_cur)
            IDLE:
                case (coin)
                    2'b01:     st_next = GET05 ;
                    2'b10:     st_next = GET10 ;
                    default:   st_next = IDLE ;
                endcase
            GET05:
                case (coin)
                    2'b01:     st_next = GET10 ;
                    2'b10:     st_next = GET15 ;
                    default:   st_next = GET05 ;
                endcase

            GET10:
                case (coin)
                    2'b01:     st_next = GET15 ;
                    2'b10:     st_next = GET20 ;
                    default:   st_next = GET10 ;
                endcase
            GET15:
                case (coin)
                    2'b01:     st_next = GET20 ;
                    2'b10:     st_next = GET25 ;
                    default:   st_next = GET15 ;
                endcase
            GET20:         st_next = IDLE ;
            GET25:         st_next = IDLE ;
            default:       st_next = IDLE ;
        endcase // case (st_cur)
    end // always @ (*)

   // (3) output logic,
   // one cycle delayed when using non-block assignment
    reg  [1:0]   change_r ;
    reg          sell_r ;
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            change_r       <= 2'b0 ;
            sell_r         <= 1'b0 ;
        end
        else if (st_cur == GET20 ) begin
            sell_r         <= 1'b1 ;
        end
        else if (st_cur == GET25) begin
            change_r       <= 2'b1 ;
            sell_r         <= 1'b1 ;
        end
        else begin
            change_r       <= 2'b0 ;
            sell_r         <= 1'b0 ;
        end
    end
    assign       sell    = sell_r ;
    assign       change  = change_r ;

endmodule
```

### 独热编码状态机

```verilog
module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // 状态方程
    assign next_state[A] = (state[A] & ~in) | (state[C] & ~in);
    assign next_state[B] = (state[A] & in) | (state[B] & in) | (state[D] & in);
    assign next_state[C] = (state[B] & ~in) | (state[D] & ~in);
    assign next_state[D] = state[C] & in;

    // 输出方程
    assign out = state[D];

endmodule
```

## ZYNQ

FPGA 和 SoC 是 Xilinx 的两大主要产品系列。

FPGA 即纯 FPGA 芯片，按照工艺节点分为 UltraScale+(16nm)、UltraScale(20nm)、7 Series(28nm)三大类，类似于 CPU 中第几代的概念。在每个类别中，又分为 Spartan、Artex、Kintex、Virtex 四个子系列，面向不同的应用场景和市场定位，性能依次提升。

除了最新的 Versal ACAP(Adaptive Compute Acceleration Platform，自适应计算加速平台)之外，Xilinx 将 SoC 系列命名为 ZYNQ 计算架构，是 FPGA + Arm 的多处理器系统，集成了 FPGA 的可编程逻辑(PL)与 ARM 处理器核心(PS)，两者之间通过 AXI(Advanced eXtensible Interface)总线实现低延迟数据传输。PS 具有固定的架构，包含了处理器和系统的存储器，适合控制或具有串行执行特性的部分以及浮点计算等；而 PL 是完全灵活的，适合并行流处理。

ZYNQ 架构分为 ZYNQ-7000 SoC、ZYNQ UltraScale+ MPSoC、ZYNQ UltraScale+ RFSoC 三类。ZYNQ-7000 SoC 的 PS 端为 Cortex A9 的 Arm 核心，为 ARMv7-A 架构，32 位；PL 端为 7 Series 的 FPGA。ZYNQ UltraScale+ MPSoC(MultiProcessor)的 PS 端为 Cortex A53 的 Arm 核心，为 ARM-v8-A 架构，64 位，另外还配备 Cortex-R5F 作为协处理器；PL 端为 UltraScale+的 FPGA。ZYNQ UltraScale+ MPSoC 再往下又可以细分为 CG、EG、EV 三类，面向的硬冲场景不同。ZYNQ UltraScale+ RFSoC(Radio Frequency)与 ZYNQ UltraScale+ MPSoC 的区别仅在于配备了高速 ADC 和 DAC 通道，用于射频领域。

## Petalinux

为了在 Xilinx 的硬件平台上运行 Linux，需要使用 Petalinux 工具。Petalinux 不是 Linux 内核，而是一套配置开发环境的工具，降低 uboot、内核、根文件系统的配置的工作量，可以从 Vivado 导出的硬件信息自动完成相关软件的配置。Petalinux 本身基于 Yocto Project(嵌入式 linux 定制框架)构建，内置了针对赛灵思硬件的交叉编译工具链(如 arm-xilinx-linux-gnueabi)，支持在 x86 主机上编译针对 ARM 架构的 Linux 内核、驱动和应用程序。Petalinux 编译后会生成嵌入式系统的核心镜像，包括 Linux 内核镜像(定制化的 Linux 内核)、设备树 Device Tree Blob(描述硬件拓扑)、根文件系统 rootfs(包含系统库、命令行工具、应用程序等，python 就在这里面)、启动加载器 bootloader(默认使用针对 Xilinx 硬件优化的 u-boot)

下面简单记录按照 Alinx 厂家的教用 Petalinux 制作板子镜像并固化到 SD 卡的过程，详细步骤见教程。由于 Petalinux 对系统版本和设置有严格要求，这里按照 Alinx 厂家的教程，在 PC 的虚拟机上安装 ubuntu16.04(或者双系统也行)并在 ubuntu 上面安装 Petalinux2017.4。用 Petalinux 定制 Linux 系统涉及 Vivado 工程和 petalinux 工程，在 Vivado 中编译生成 bit 文件，导出硬件信息并得到包含硬件信息的 hdf 文件，Petalinux 根据 hdf 文件配置 uboot ，内核、文件系统等。

```bash
# 创建Petalinux工程
petalinux-create --type project --template zynq --name ax_peta
# 基于Vivado导出的hdf文件，由配置界面配置硬件信息
petalinux-config --get-hw-description ../linux_base.sdk
# 由配置界面配置内核
petalinux-config -c kernel
# 由配置界面配置根文件系统
petalinux-config -c rootfs
# 编译
petalinux-build
# 生成BOOT文件
petalinux-package --boot --fsbl ./images/linux/zynq_fsbl.elf --fpga --u-boot --force
```

在 PC 的 Linux 上用 disk 工具，分区出 FAT 和 EXT，此时可以把文件放入 SD 卡的 EXT 分区中(Windows 系统是不显示 EXT 分区的，Linux 可以，所以放文件要在 PC 端的 Linux 下操作)；然后将工程目录 images --> linux 目录中的 BOOT.BIN 和 image.ub 复制到 SD 卡的 FAT 分区即可。如果需要打包成 img 镜像，使用 imageUSB 工具即可。

Petalinux 的版本和 python 的版本是绑定的，但 Xilinx 的官方文档中并没有给出对应关系，目前已知 Petalinux2023.1 对应 python3.10.6。如果需要改 python 版本就需要尝试安装不同的 Petalinux 版本并完成整套的 Linux 系统定制，在板子上运行起来编译出的镜像之后，由 python3 --version 才能查到这个 Petalinux 版本对应的 python 版本是否符合要求。

另外再多说一句图形界面相关的问题(完全可以不用图形界面拥抱命令行，不过已经问过了相关的情况，这里就一起记录下来了)，Petalinux 自带桌面系统 matchbox，但这个系统与 ZYNQ 7000 架构的适配有 bug；Alinx 厂家是自己移特制 Linux 内核和经过移植的 Debian 桌面文件系统，理论上应该也可以自己移植 Linux 其它发行版如 ubuntu 的桌面系统，但移植时涉及文件系统，python 版本和库也要在此时一并作好处理；不过移植 Linux 在没有接触过的情况下工作量太大坑太多，并且图形界面也不是刚需，这里就不配置了。

## 参考资料

[FPGA 和硬件加速](https://www.bilibili.com/video/BV1xo4y1c7AD/?vd_source=1d0891b41fe4e23dbf197eaf61dfa468)

[ZYNQ Soc 介绍](https://fpga.eetrend.com/content/2022/100567012.html)

[Xilinx petalinux BSP](https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/embedded-design-tools/2025-1.html)
